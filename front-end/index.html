<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="description" content="M.AX - AI Assistant">
  <meta name="theme-color" content="#0a0c10">
  <title>M.AX</title>
  <meta property="og:title" content="M.AX - Journey Mapping Assistant">
  <meta property="og:description" content="An intelligent AI assistant for creating detailed user journey maps.">
  <meta property="og:image" content="https://journey-mapper.monumental.ax/max_splash.png">
  <meta property="og:url" content="https://journey-mapper.monumental.ax/">
  <meta property="og:type" content="website">
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Sorts+Mill+Goudy:ital@0;1&display=swap" rel="stylesheet">

  <!-- Fonts -->
  <style>
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Light.otf') format('opentype');
      font-weight: 300;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-LightItalic.otf') format('opentype');
      font-weight: 300;
      font-style: italic;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Regular.otf') format('opentype');
      font-weight: 400;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Italic.otf') format('opentype');
      font-weight: 400;
      font-style: italic;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Bold.otf') format('opentype');
      font-weight: 700;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-BoldItalic.otf') format('opentype');
      font-weight: 700;
      font-style: italic;
    }

    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Light.otf') format('opentype');
      font-weight: 300;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Book.otf') format('opentype');
      font-weight: 350; /* Fallback for Book */
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Regular.otf') format('opentype');
      font-weight: 400;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-SemiBold.otf') format('opentype');
      font-weight: 600;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Bold.otf') format('opentype');
      font-weight: 700;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Black.otf') format('opentype');
      font-weight: 900;
      font-style: normal;
    }
  </style>

  <!-- Shared Journey Viewer (renderer.js output styles) -->
  <link rel="stylesheet" href="styles/journey-viewer.css?v=2">
  
  <style>
    /* ========================================
       CSS VARIABLES
       ======================================== */
    :root {
      --max-color-background: #0a0c10;
      --max-color-surface-primary: #12141a;
      --max-color-surface-secondary: #1a1d24;
      --max-color-surface-tertiary: #22262f;
      --max-color-surface-hover: #2a2f3a;
      
      --max-color-text-primary: #f0f2f5;
      --max-color-text-secondary: #9ca3b4;
      --max-color-text-tertiary: #6b7280;
      --max-color-text-inverse: #0a0c10;
      
      --max-color-border: #2a2f3a;
      --max-color-border-subtle: #1e2229;
      
      --max-color-accent: #ed2224;
      --max-color-accent-hover: #ff4d4f;
      --max-color-accent-subtle: rgba(237, 34, 36, 0.15);
      
      --max-color-error: #ef4444;
      --max-color-error-subtle: rgba(239, 68, 68, 0.15);
      
      --max-color-ai-gradient-start: #ed2224;
      --max-color-ai-gradient-end: #c41e20;
      
      --max-font-family: 'Messina Sans', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --max-font-family-mono: 'Messina Sans Mono', 'SF Mono', Monaco, monospace;
      --max-radius-small: 8px;
      --max-radius-medium: 12px;
      --max-radius-large: 16px;
      --max-radius-xlarge: 20px;
      --max-radius-full: 9999px;
      
      --max-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.3);
      --max-shadow-glow: 0 0 20px rgba(237, 34, 36, 0.3);
    }

    /* ========================================
       RESET & BASE
       ======================================== */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      height: 100dvh;
      overflow: hidden;
      /* iOS Safari specific fix to prevent bounce/overscroll */
      position: fixed;
      width: 100%;
    }

    body {
      font-family: var(--max-font-family);
      font-size: 15px;
      line-height: 1.5;
      color: var(--max-color-text-primary);
      background: var(--max-color-background);
      -webkit-font-smoothing: antialiased;
    }

    /* ========================================
       APP LAYOUT
       ======================================== */
    .max-app {
      display: flex;
      flex-direction: column;
      height: 100%;
      height: 100dvh;
      width: 100%;
      margin: 0 auto;
    }

    .max-main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* ========================================
       CHAT CANVAS (LEFT) - NOW RIGHT
       ======================================== */
    .max-chat-canvas {
      flex: 1 !important;
      width: auto !important;
      max-width: none !important;
      min-width: 0 !important;
      border-left: 1px solid var(--max-color-border-subtle);
      background: var(--max-color-surface-primary);
      display: flex;
      flex-direction: column;
      color: var(--max-color-text-tertiary);
      font-size: 14px;
      overflow: hidden;
      position: relative; /* For absolute controls */
    }

    /* Panzoom Wrapper */
    .panzoom-viewport {
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: grab;
      position: relative;
      touch-action: none; /* Enable native pinch gestures handling by Panzoom */
      /* Grid Background on Viewport */
      background-color: #1a1d26;
      background-image: 
        linear-gradient(to right, rgba(46, 204, 113, 0.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(46, 204, 113, 0.08) 1px, transparent 1px);
      background-size: 120px 120px;
    }
    .panzoom-viewport:active {
      cursor: grabbing;
    }

    .journey-dashboard {
      padding: 80px; /* More padding for aesthetic */
      width: max-content; /* Allow growth */
      min-width: 100%;
      min-height: 100%;
      /* transform-origin: 0 0 !important; - REMOVED to let Panzoom manage origin */
      position: relative; /* Ensure offsetParent for children */
    }

    /* .journey-board-container — see styles/journey-viewer.css */

    /* JSON View Override - Reset to standard scroll */
    .journey-dashboard.json-view-mode {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        cursor: text;
        transform: none !important; /* Force reset transforms if any */
    }
    
    /* Panzoom Controls Styling */
    .panzoom-controls {
        position: absolute;
        bottom: 24px;
        right: 24px;
        display: flex;
        gap: 8px;
        z-index: 100;
        background: var(--max-color-surface-secondary);
        padding: 6px;
        border-radius: var(--max-radius-medium);
        border: 1px solid var(--max-color-border);
        box-shadow: var(--max-shadow-soft);
        flex-wrap: wrap; /* Allow wrapping on small screens if needed */
        max-width: 90vw; /* Prevent overflow on mobile */
        justify-content: flex-end;
    }

    .panzoom-btn {
        height: 36px;
        padding: 0 12px; /* Text padding */
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: 1px solid transparent;
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-primary);
        cursor: pointer;
        transition: all 0.15s ease;
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        white-space: nowrap;
    }

    .panzoom-btn:hover {
        background: var(--max-color-surface-tertiary);
        border-color: var(--max-color-border-subtle);
    }

    .panzoom-btn svg {
        display: none; /* Hide icons in favor of text if present, or just use text */
    }

    /* .journey-header, .journey-title, .journey-role — see styles/journey-viewer.css */

    /* .context-card, .context-content — see styles/journey-viewer.css */

    /* .journey-table, .phase-header, .swimlane-*, .journey-cell, .cell-* — see styles/journey-viewer.css */

    /* ========================================
       MOBILE VIEW (Unified Canvas)
       ======================================== */
    /* Mobile-specific list view removed to ensure parity with desktop canvas */

    /* Mobile Responsive Logic - Cleaned */
    /* Mobile-specific adjustments removed to maintain desktop parity */

    /* .cell-detail-overlay, .cell-detail-modal — see styles/journey-viewer.css */

    /* ========================================
       HEADER
       ======================================== */
    .max-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 24px;
        border-bottom: 1px solid var(--max-color-border-subtle);
        flex-shrink: 0;
    }

    .max-logo {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .header-template-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        color: #ffffff;
    }

    .header-template-icon:empty {
        display: none;
    }

    .header-template-icon svg {
        height: 24px;
        width: 24px;
    }

    .header-template-name {
        font-family: var(--max-font-family-sans, sans-serif);
        font-size: 16.8px;
        font-weight: 700;
        color: var(--max-color-accent);
        letter-spacing: 0.02em;
        text-transform: uppercase;
    }

    .header-template-name:empty {
        display: none;
    }

    .max-logo-icon {
        width: 36px;
        height: 36px;
        background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end));
        border-radius: var(--max-radius-small);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
    }

    .max-logo-icon svg {
        width: 20px;
        height: 20px;
    }

    .max-logo-text {
        font-family: var(--max-font-family);
        font-size: 20px;
        font-weight: 600;
        letter-spacing: -0.02em;
    }

    .max-logo-text span {
        color: var(--max-color-accent);
    }

    .max-status {
        font-family: var(--max-font-family-mono);
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        color: var(--max-color-text-tertiary);
    }

    .max-status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--max-color-text-tertiary);
    }

    .max-status-dot.connected {
        background: #22c55e;
    }

    .max-status-dot.error {
        background: var(--max-color-error);
    }

    /* ========================================
       CHAT CONTAINER (RIGHT)
       ======================================== */
    .max-chat-container {
        flex: 0 0 480px !important;
        width: 480px !important;
        max-width: 480px !important;
        min-width: 480px !important;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background: var(--max-color-background);
    }

    /* ========================================
       MESSAGES AREA
       ======================================== */
    .max-messages {
        flex: 1;
        overflow-y: auto;
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 24px;
    }

    .max-messages::-webkit-scrollbar {
        width: 6px;
    }

    .max-messages::-webkit-scrollbar-track {
        background: transparent;
    }

    .max-messages::-webkit-scrollbar-thumb {
        background: var(--max-color-border);
        border-radius: var(--max-radius-full);
    }

    /* Welcome State */
    .max-welcome {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 40px 20px;
    }

    .max-welcome-icon {
        width: 72px;
        height: 72px;
        background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end));
        border-radius: var(--max-radius-large);
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 24px;
        box-shadow: var(--max-shadow-glow);
    }

    .max-welcome-icon svg {
        width: 36px;
        height: 36px;
        color: white;
    }

    .max-welcome h1 {
        font-size: 28px;
        font-weight: 600;
        margin-bottom: 12px;
        letter-spacing: -0.02em;
    }

    .max-welcome p {
        font-size: 16px;
        color: var(--max-color-text-secondary);
        max-width: 400px;
        margin-bottom: 32px;
    }

    .max-suggestions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
    }

    .max-suggestion {
        padding: 10px 16px;
        background: var(--max-color-surface-secondary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-full);
        color: var(--max-color-text-secondary);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .max-suggestion:hover {
        background: var(--max-color-surface-hover);
        color: var(--max-color-text-primary);
        border-color: var(--max-color-accent);
    }

    /* ========================================
       MESSAGE BUBBLES
       ======================================== */
    .max-message {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-width: 100%;
        animation: messageIn 0.3s ease;
    }

    @keyframes messageIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .max-message--user {
        align-items: flex-end;
    }

    .max-message-header {
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        line-height: 1;
        width: fit-content;
        letter-spacing: 0.05em;
    }

    .max-message--ai .max-message-header {
        background: var(--max-color-accent);
    }

    .max-message--user .max-message-header {
        background: var(--max-color-surface-tertiary);
        color: var(--max-color-text-secondary);
    }

    /* AI Bubble - Gray */
    .max-message--ai .max-message-bubble {
        background: var(--max-color-surface-secondary);
        border: 1px solid var(--max-color-border-subtle);
        border-radius: var(--max-radius-medium);
        border-top-left-radius: 4px; /* Align with header */
    }

    /* User Bubble - Red */
    .max-message--user .max-message-bubble {
        background: var(--max-color-accent);
        color: white;
        border: 1px solid var(--max-color-accent); /* Match border to bg */
        border-radius: var(--max-radius-medium);
        border-top-right-radius: 4px;
        margin-left: auto;
    }

    .max-message-content {
        flex: 1;
        min-width: 0;
        max-width: 100%;
    }

    .max-message-bubble {
        padding: 14px 18px;
        line-height: 1.6;
    }

    .max-message--error .max-message-bubble {
        background: var(--max-color-error-subtle);
        border-color: var(--max-color-error);
        color: var(--max-color-error);
    }

    .max-message-bubble h3 {
        font-size: 16px;
        font-weight: 600;
        margin-top: 12px;
        margin-bottom: 8px;
        color: inherit;
    }

    .max-message-bubble p {
        margin-bottom: 12px;
    }

    .max-message-bubble p:last-child {
        margin-bottom: 0;
    }

    .max-message-bubble ul, .max-message-bubble ol {
        margin: 12px 0;
        padding-left: 20px;
    }

    .max-message-bubble li {
        margin-bottom: 6px;
    }

    .max-message-bubble code {
        background: var(--max-color-surface-tertiary);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 13px;
        font-family: var(--max-font-family-mono);
    }

    .max-message-bubble pre {
        background: var(--max-color-surface-primary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-small);
        padding: 12px;
        margin: 12px 0;
        overflow-x: auto;
    }

    .max-message-bubble pre code {
        background: transparent;
        padding: 0;
    }

    /* Streaming cursor */
    .max-message-bubble .streaming-cursor {
        display: inline-block;
        width: 2px;
        height: 1em;
        background: var(--max-color-accent);
        margin-left: 2px;
        animation: cursorBlink 1s step-end infinite;
        vertical-align: text-bottom;
    }

    @keyframes cursorBlink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }

    .max-message-actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        opacity: 0;
        transition: opacity 0.15s ease;
    }

    .max-message:hover .max-message-actions {
        opacity: 1;
    }

    .max-message-action {
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 6px 10px;
        background: transparent;
        border: none;
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-tertiary);
        font-size: 11px;
        font-family: var(--max-font-family-mono);
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .max-message-action:hover {
        background: var(--max-color-surface-tertiary);
        color: var(--max-color-text-secondary);
    }

    .max-message-action svg {
        width: 14px;
        height: 14px;
    }

    /* ========================================
       TYPING INDICATOR
       ======================================== */
    .max-typing {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        margin-bottom: 24px;
    }

    .max-typing-dots {
        display: flex;
        gap: 4px;
        padding: 16px 20px;
        background: var(--max-color-surface-secondary);
        border-radius: var(--max-radius-large);
        border-top-left-radius: 4px;
        border: 1px solid var(--max-color-border-subtle);
    }

    .max-typing-dot {
        width: 8px;
        height: 8px;
        background: var(--max-color-text-tertiary);
        border-radius: 50%;
        animation: typingBounce 1.4s ease-in-out infinite;
    }

    .max-typing-dot:nth-child(2) { animation-delay: 0.15s; }
    .max-typing-dot:nth-child(3) { animation-delay: 0.3s; }

    @keyframes typingBounce {
        0%, 60%, 100% {
            transform: translateY(0);
            opacity: 0.4;
        }
        30% {
            transform: translateY(-8px);
            opacity: 1;
        }
    }

    /* ========================================
       INPUT AREA
       ======================================== */
    .max-input-area {
        padding: 16px 24px 24px;
        border-top: 1px solid var(--max-color-border-subtle);
    }

    .max-input-wrapper {
        display: flex;
        align-items: flex-end;
        gap: 12px;
        background: var(--max-color-surface-secondary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-xlarge);
        padding: 8px 8px 8px 20px;
        transition: all 0.2s ease;
    }

    .max-input-wrapper:focus-within {
        border-color: var(--max-color-accent);
        box-shadow: var(--max-shadow-glow);
    }

    .max-input-wrapper.disabled {
        opacity: 0.6;
        pointer-events: none;
    }

    .max-input {
        flex: 1;
        background: transparent;
        border: none;
        outline: none;
        font-family: inherit;
        font-size: 15px;
        color: var(--max-color-text-primary);
        resize: none;
        max-height: 150px;
        min-height: 24px;
        line-height: 1.5;
        padding: 8px 0;
    }

    .max-input::placeholder {
        color: var(--max-color-text-tertiary);
    }

    .max-send-button {
        width: 44px;
        height: 44px;
        background: var(--max-color-accent);
        border: none;
        border-radius: var(--max-radius-medium);
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
        flex-shrink: 0;
    }

    .max-send-button:hover:not(:disabled) {
        background: var(--max-color-accent-hover);
        transform: scale(1.05);
    }

    .max-send-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
    }

    .max-send-button svg {
        width: 20px;
        height: 20px;
    }

    .max-input-hint {
        font-family: var(--max-font-family-mono);
        text-align: center;
        font-size: 11px;
        color: var(--max-color-text-tertiary);
        margin-top: 10px;
    }

    .max-input-hint kbd {
        background: var(--max-color-surface-tertiary);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: inherit;
    }

    /* ========================================
       COMPLETION STATE
       ======================================== */
    /* Hide Chat Container */
    body.journey-complete .max-chat-container {
        display: none !important;
    }
    
    /* Full Width Canvas */
    body.journey-complete .max-chat-canvas {
        flex: 0 0 100% !important;
        width: 100% !important;
        max-width: 100% !important;
        border-right: none;
    }

    /* Hide Mobile Toggle in Complete State */
    body.journey-complete .mobile-toggle-btn {
        display: none !important;
    }

    /* Ensure proper reset of Panzoom on transition to complete */
    body.journey-complete .journey-dashboard {
        width: max-content; /* Ensure it can still pan/zoom properly */
        min-width: 100%;
    }

    /* Panzoom Controls Styling */
    .panzoom-controls {
        position: absolute;
        bottom: 24px;
        right: 24px;
        display: flex;
        gap: 8px;
        z-index: 100;
        background: var(--max-color-surface-secondary);
        padding: 6px;
        border-radius: var(--max-radius-medium);
        border: 1px solid var(--max-color-border);
        box-shadow: var(--max-shadow-soft);
        flex-wrap: wrap; /* Allow wrapping on small screens if needed */
        max-width: 90vw; /* Prevent overflow on mobile */
        justify-content: flex-end;
    }

    .panzoom-btn {
        height: 36px;
        padding: 0 12px; /* Text padding */
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: 1px solid transparent;
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-primary);
        cursor: pointer;
        transition: all 0.15s ease;
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        white-space: nowrap;
    }

    .panzoom-btn:hover {
        background: var(--max-color-surface-tertiary);
        border-color: var(--max-color-border-subtle);
    }
    .mobile-toggle-btn {
        display: none;
        padding: 8px 16px;
        background: var(--max-color-surface-tertiary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-medium);
        color: var(--max-color-text-primary);
        font-size: 13px;
        font-family: var(--max-font-family-mono);
        font-weight: 500;
        cursor: pointer;
        margin-right: 12px;
        transition: box-shadow 0.3s ease, border-color 0.3s ease;
    }

    /* MAP button pulse when journey updates while user is in chat view */
    @keyframes mapPulse {
        0%, 100% { box-shadow: 0 0 4px var(--max-color-accent); }
        50% { box-shadow: 0 0 14px var(--max-color-accent); }
    }
    .mobile-toggle-btn.map-updated {
        border-color: var(--max-color-accent);
        animation: mapPulse 1.5s ease-in-out infinite;
    }

    @media (max-width: 768px) {
        .max-main-content {
            flex-direction: column; /* Normal column, we toggle visibility */
        }
        .max-chat-canvas, .max-chat-container {
            width: 100% !important;
            max-width: 100% !important;
            min-width: 100% !important;
            flex: 1 !important;
            height: 100%;
            border: none;
        }
        
        /* Toggle Logic */
        body:not(.show-map) .max-chat-canvas { display: none !important; }
        body.show-map .max-chat-container { display: none !important; }
        
        .mobile-toggle-btn { display: block; }
        
        /* Header adjustments */
        .max-header { padding: 12px 16px; }
        .max-logo-text { display: none; } /* Save space */
        
        /* Hide Model Name on Mobile */
        .desktop-only { display: none !important; }
    }

    /* Template Picker / New Button */
    .template-picker-wrapper {
        position: relative;
    }

    .reset-btn {
        background: none;
        border: 1px solid var(--max-color-border);
        border-radius: 4px;
        color: var(--max-color-text-tertiary);
        cursor: pointer;
        padding: 4px 8px;
        margin-left: 8px;
        font-family: var(--max-font-family-mono);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: all 0.15s ease;
    }
    .reset-btn:hover {
        background: var(--max-color-surface-tertiary);
        color: var(--max-color-text-primary);
        border-color: var(--max-color-text-secondary);
    }

    .template-picker-panel {
        position: fixed;
        top: 56px;
        right: 16px;
        width: 320px;
        max-height: 420px;
        background: var(--max-color-surface-primary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-medium);
        box-shadow: 0 12px 40px rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    @media (max-width: 768px) {
        .template-picker-panel {
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            max-height: 100%;
            border-radius: 0;
        }
    }

    .template-picker-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        border-bottom: 1px solid var(--max-color-border);
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--max-color-text-secondary);
        font-weight: 600;
    }

    .template-picker-close {
        background: none;
        border: none;
        color: var(--max-color-text-tertiary);
        cursor: pointer;
        font-size: 18px;
        padding: 0 4px;
        line-height: 1;
    }

    .template-picker-list {
        flex: 1;
        overflow-y: auto;
        padding: 4px;
    }

    .template-picker-item {
        display: flex;
        gap: 12px;
        padding: 12px;
        border-radius: var(--max-radius-small);
        cursor: pointer;
        transition: all 0.15s;
        align-items: flex-start;
    }

    .template-picker-item:hover {
        background: var(--max-color-surface-secondary);
    }

    .template-picker-icon {
        flex-shrink: 0;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--max-color-accent-subtle);
        border-radius: var(--max-radius-small);
        color: var(--max-color-accent);
    }

    .template-picker-info {
        flex: 1;
        min-width: 0;
    }

    .template-picker-name {
        font-weight: 600;
        font-size: 14px;
        color: var(--max-color-text-primary);
        margin-bottom: 2px;
    }

    .template-picker-desc {
        font-size: 12px;
        color: var(--max-color-text-tertiary);
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }

    .template-picker-blank {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px;
        border: none;
        border-top: 1px solid var(--max-color-border);
        background: transparent;
        color: var(--max-color-text-secondary);
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        cursor: pointer;
        transition: all 0.15s;
    }

    .template-picker-blank:hover {
        background: var(--max-color-surface-secondary);
        color: var(--max-color-text-primary);
    }

    .template-picker-loading {
        padding: 24px;
        text-align: center;
        color: var(--max-color-text-tertiary);
        font-size: 13px;
    }

    .template-picker-empty {
        padding: 24px;
        text-align: center;
        color: var(--max-color-text-tertiary);
        font-size: 13px;
        font-style: italic;
    }

    /* ========================================
       NAV BUTTONS & HAMBURGER MENU
       ======================================== */
    .max-header-right {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .header-nav {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .header-nav.desktop-only {
        display: none;
    }

    @media (min-width: 769px) {
        .header-nav.desktop-only {
            display: flex;
        }
    }

    .nav-btn {
        font-family: var(--max-font-family-mono);
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        padding: 6px 12px;
        background: transparent;
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-secondary);
        cursor: pointer;
        transition: all 0.15s ease;
        white-space: nowrap;
    }

    .nav-btn:hover {
        background: var(--max-color-surface-tertiary);
        color: var(--max-color-text-primary);
        border-color: var(--max-color-text-secondary);
    }

    .hamburger-btn {
        display: none;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        background: transparent;
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-secondary);
        cursor: pointer;
    }

    .hamburger-btn:hover {
        background: var(--max-color-surface-tertiary);
        color: var(--max-color-text-primary);
    }

    .mobile-only-flex {
        display: none;
    }

    @media (max-width: 768px) {
        .mobile-only-flex {
            display: flex;
        }
    }

    /* Mobile Menu Overlay */
    .mobile-menu-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: none;
        justify-content: flex-end;
    }

    .mobile-menu-overlay.active {
        display: flex;
    }

    .mobile-menu-content {
        background: var(--max-color-surface-primary);
        width: 260px;
        height: 100%;
        display: flex;
        flex-direction: column;
        animation: slideInRight 0.2s ease;
    }

    @keyframes slideInRight {
        from { transform: translateX(100%); }
        to { transform: translateX(0); }
    }

    .mobile-menu-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid var(--max-color-border);
    }

    .mobile-menu-close {
        background: none;
        border: none;
        color: var(--max-color-text-secondary);
        font-size: 24px;
        cursor: pointer;
        padding: 0 4px;
    }

    .mobile-menu-nav {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 12px 0;
    }

    .mobile-menu-item {
        display: block;
        width: 100%;
        padding: 14px 20px;
        background: none;
        border: none;
        text-align: left;
        color: var(--max-color-text-primary);
        font-family: var(--max-font-family-mono);
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        cursor: pointer;
        transition: background 0.15s;
    }

    .mobile-menu-item:hover {
        background: var(--max-color-surface-secondary);
    }

    .mobile-menu-footer {
        padding: 12px 20px;
        border-top: 1px solid var(--max-color-border);
    }

    .mobile-model-label {
        font-family: var(--max-font-family-mono);
        font-size: 9px;
        color: var(--max-color-text-tertiary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    /* ========================================
       FEEDBACK PANEL
       ======================================== */
    .feedback-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.6);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .feedback-card {
        background: var(--max-color-surface-primary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-large);
        padding: 24px;
        width: 90%;
        max-width: 480px;
        box-shadow: 0 16px 48px rgba(0,0,0,0.5);
    }

    .feedback-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
    }

    .feedback-header h3 {
        font-size: 18px;
        font-weight: 600;
    }

    .feedback-close {
        background: none;
        border: none;
        color: var(--max-color-text-tertiary);
        font-size: 24px;
        cursor: pointer;
    }

    .feedback-textarea {
        width: 100%;
        padding: 12px;
        background: var(--max-color-surface-secondary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-primary);
        font-family: var(--max-font-family);
        font-size: 14px;
        resize: vertical;
        min-height: 100px;
    }

    .feedback-textarea:focus {
        outline: none;
        border-color: var(--max-color-accent);
    }

    .feedback-actions {
        margin-top: 16px;
        display: flex;
        justify-content: flex-end;
    }

    .feedback-submit-btn {
        padding: 10px 20px;
        background: var(--max-color-accent);
        color: #fff;
        border: none;
        border-radius: var(--max-radius-small);
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.15s;
    }

    .feedback-submit-btn:hover {
        background: var(--max-color-accent-hover);
    }

    .feedback-submit-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    .feedback-status {
        margin-top: 12px;
        font-size: 13px;
        padding: 8px;
        border-radius: var(--max-radius-small);
        text-align: center;
    }

    .feedback-status.success {
        background: rgba(34, 197, 94, 0.15);
        color: #22c55e;
    }

    .feedback-status.error {
        background: var(--max-color-error-subtle);
        color: var(--max-color-error);
    }

    /* ========================================
       AUTH GATE (Per-Template)
       ======================================== */
    .auth-gate-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(10, 12, 16, 0.95);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .auth-gate-card {
        background: var(--max-color-surface-primary);
        border: 1px solid var(--max-color-border);
        border-radius: var(--max-radius-large);
        padding: 40px 32px;
        max-width: 400px;
        width: 90%;
        text-align: center;
        box-shadow: 0 16px 48px rgba(0,0,0,0.5);
    }

    .auth-gate-card h3 {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 8px;
    }

    .auth-gate-desc {
        color: var(--max-color-text-secondary);
        font-size: 14px;
        margin-bottom: 24px;
    }

    .google-signin-btn {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        padding: 12px 24px;
        background: #fff;
        color: #3c4043;
        border: 1px solid #dadce0;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
    }

    .google-signin-btn:hover {
        background: #f8f9fa;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* ========================================
       PDF EXPORT STYLES
       ======================================== */
    .pdf-export-mode {
        --max-color-background: #ffffff !important;
        --max-color-surface-primary: #ffffff !important;
        --max-color-surface-secondary: #ffffff !important;
        --max-color-surface-tertiary: #f3f4f6 !important;
        
        --max-color-text-primary: #111827 !important;
        --max-color-text-secondary: #4b5563 !important;
        --max-color-text-tertiary: #6b7280 !important;
        
        --max-color-border: #e5e7eb !important;
        --max-color-border-subtle: #f3f4f6 !important;
        
        color: #000000 !important;
        background: #ffffff !important;
    }

    /* Force background colors for PDF generation */
    .pdf-export-mode .journey-cell {
        background: #ffffff !important;
        border: 1px solid #e5e7eb !important;
        color: #000 !important;
        break-inside: avoid;
        page-break-inside: avoid;
    }

    /* Page Break Helper */
    .html2pdf__page-break {
        page-break-before: always;
    }
  </style>
</head>
<body>
  <div class="max-app">
    
    <!-- Header -->
    <header class="max-header">
      <div class="max-logo">
          <span id="headerTemplateIcon" class="header-template-icon"></span>
          <img id="headerLogoImg" src="max_header.svg" alt="M.AX" style="height: 24px; width: auto;">
          <span id="headerTemplateName" class="header-template-name"></span>
      </div>
      <div class="max-header-right">
        <button id="mobileToggleBtn" class="mobile-toggle-btn" onclick="toggleMobileView()">Map</button>
        
        <!-- Desktop Nav Buttons -->
        <nav class="header-nav desktop-only">
            <div class="template-picker-wrapper">
                <button id="templatePickerBtn" class="nav-btn" title="Choose a journey template">CHOOSE</button>
            </div>
            <button class="nav-btn" onclick="window.location.href='/admin'">CREATE</button>
            <button class="nav-btn" onclick="openAboutModal()">ABOUT</button>
            <button class="nav-btn" id="feedbackNavBtn" onclick="openFeedbackPanel()">FEEDBACK</button>
        </nav>

        <!-- Template Picker (shared mobile/desktop) -->
        <div id="templatePickerPanel" class="template-picker-panel" style="display: none;">
            <div class="template-picker-header">
                <span>Choose a Journey</span>
                <button class="template-picker-close" onclick="closeTemplatePicker()">&times;</button>
            </div>
            <div id="templatePickerList" class="template-picker-list">
                <div class="template-picker-loading">Loading...</div>
            </div>
            <button class="template-picker-blank" onclick="startBlankJourney()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                Blank Journey
            </button>
        </div>

        <!-- Hamburger (Mobile) -->
        <button id="hamburgerBtn" class="hamburger-btn mobile-only-flex" aria-label="Menu">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
        </button>
      </div>
    </header>

    <!-- Mobile Hamburger Menu -->
    <div id="mobileMenu" class="mobile-menu-overlay">
        <div class="mobile-menu-content">
            <div class="mobile-menu-header">
                <img src="max_header.svg" alt="M.AX" style="height: 24px;">
                <button class="mobile-menu-close" onclick="closeMobileMenu()">&times;</button>
            </div>
            <nav class="mobile-menu-nav">
                <button class="mobile-menu-item" onclick="openTemplatePicker(); closeMobileMenu();">CHOOSE</button>
                <button class="mobile-menu-item" onclick="window.location.href='/admin'; closeMobileMenu();">CREATE</button>
                <button class="mobile-menu-item" onclick="openAboutModal(); closeMobileMenu();">ABOUT</button>
                <button class="mobile-menu-item" onclick="openFeedbackPanel(); closeMobileMenu();">FEEDBACK</button>
            </nav>
            <div class="mobile-menu-footer">
                <span id="mobileModelName" class="mobile-model-label">Loading model...</span>
            </div>
        </div>
    </div>

    <!-- Feedback Panel Overlay -->
    <div id="feedbackPanel" class="feedback-overlay" style="display: none;">
        <div class="feedback-card">
            <img src="max_header.svg" alt="M.AX" style="height: 32px; margin-bottom: 20px;">
            <div class="feedback-header">
                <h3>Please give us feedback</h3>
                <button class="feedback-close" onclick="closeFeedbackPanel()">&times;</button>
            </div>
            <textarea id="feedbackText" class="feedback-textarea" rows="5" placeholder="What's on your mind? Tell us how we can improve..."></textarea>
            <div class="feedback-actions">
                <button class="feedback-submit-btn" id="feedbackSubmitBtn" onclick="submitFeedback()">Submit Feedback</button>
            </div>
            <div id="feedbackStatus" class="feedback-status" style="display: none;"></div>
        </div>
    </div>

    <!-- About Modal -->
    <div id="aboutModal" class="feedback-overlay" style="display: none;">
        <div class="feedback-card" style="max-width: 520px;">
            <div class="feedback-header">
                <span></span>
                <button class="feedback-close" onclick="closeAboutModal()">&times;</button>
            </div>
            <img src="max_header.svg" alt="M.AX" style="height: 32px; margin-bottom: 20px;">
            <div style="color: var(--max-color-text-primary); font-size: 14px; line-height: 1.7;">
                <p style="margin-bottom: 16px;"><strong style="font-size: 16px;">About this App</strong></p>
                <p style="margin-bottom: 16px;">M.AX Journey is an AI-powered journey mapping tool that helps teams understand their customers through structured, conversational research. It guides users through an expert-level UX interview, automatically building a visual journey map in real time.</p>
                <p style="margin-bottom: 16px;"><strong style="font-size: 16px;">Craft Intelligence</strong></p>
                <p>Built by Monumental, M.AX Journey combines ethnographic research methodology with generative AI to deliver actionable insights. Every journey map captures not just what users do, but what they think, feel, and need &mdash; turning conversations into strategy.</p>
            </div>
        </div>
    </div>

    <!-- Auth Gate (for requireAuth templates) -->
    <div id="authGate" class="auth-gate-overlay" style="display: none;">
        <div class="auth-gate-card">
            <img src="max_header.svg" alt="M.AX" style="height: 32px; margin-bottom: 20px;">
            <h3>Sign in to begin</h3>
            <p class="auth-gate-desc">This journey requires Google authentication to proceed.</p>
            <button id="authGateSignInBtn" class="google-signin-btn">
                <svg width="18" height="18" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"/><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"/><path fill="#34A853" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"/><path fill="#FBBC05" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"/></svg>
                Sign in with Google
            </button>
            <div id="authGateError" style="display: none; color: #ef4444; margin-top: 12px; font-size: 13px;"></div>
        </div>
    </div>

    <div class="max-main-content">
      <!-- Chat Container (Left) -->
      <div class="max-chat-container">
        
        <!-- Messages Area -->
        <div class="max-messages" id="messagesArea">
        </div>

      <!-- Input Area -->
      <div class="max-input-area">
        <div class="max-input-wrapper" id="inputWrapper">
          <textarea 
            class="max-input" 
            id="chatInput"
            placeholder="Message M.AX..."
            rows="1"
            onkeydown="handleKeyDown(event)"
            oninput="autoResize(this); toggleSendButton()"
          ></textarea>
          <button class="max-send-button" id="sendButton" onclick="sendMessage()" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 2L11 13"/>
              <path d="M22 2L15 22L11 13L2 9L22 2Z"/>
            </svg>
          </button>
        </div>
        <div class="max-input-hint" style="display: none;">
          <kbd>Enter</kbd> to send · <kbd>Shift + Enter</kbd> for new line
        </div>
      </div>
    </div>

        <!-- Chat Canvas (Right) — powered by JourneyViewer -->
      <div class="max-chat-canvas" id="chatCanvas">
        <div id="journeyViewerRoot" style="position: relative; flex: 1; min-height: 0; overflow: hidden;"></div>
      </div>
      
      <!-- Cell Detail Modal (Hidden) -->
      <div class="cell-detail-overlay" id="cellModal" onclick="closeCellModal(event)">
        <div class="cell-detail-modal">
          <h3 id="modalTitle" style="font-size: 18px; margin-bottom: 12px; color: var(--max-color-text-primary);">Action</h3>
          <div id="modalContext" style="color: var(--max-color-text-secondary); line-height: 1.6;">Context</div>
          <button onclick="closeCellModal(null)" style="margin-top: 20px; padding: 8px 16px; background: var(--max-color-surface-tertiary); border: 1px solid var(--max-color-border); color: var(--max-color-text-primary); border-radius: 6px; cursor: pointer;">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase Auth SDK (for optional per-template auth) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
  <script>
    // Global Error Reporting to Winston Backend
    (function() {
        const ORIGINAL_CONSOLE_ERROR = console.error;
        
        function sendLog(level, message, context = {}) {
            // Avoid infinite loops if the fetch itself fails
            try {
                fetch('/api/logs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        level,
                        message: typeof message === 'string' ? message : JSON.stringify(message),
                        context: {
                            url: window.location.href,
                            ...context
                        },
                        userAgent: navigator.userAgent,
                        timestamp: new Date().toISOString()
                    })
                }).catch(e => {
                    // Fallback to original console to ensure we see it locally at least
                    ORIGINAL_CONSOLE_ERROR.call(console, 'Failed to send log to backend:', e);
                });
            } catch (e) { /* ignore */ }
        }

        // 1. Capture Global Uncaught Errors
        window.onerror = function(msg, url, line, col, error) {
            sendLog('error', `Uncaught: ${msg}`, {
                file: url,
                line,
                line,
                col,
                stack: error ? error.stack : 'no-stack'
            });
            return false; // Let default handler run too
        };

        // 2. Capture Unhandled Promise Rejections
        window.onunhandledrejection = function(event) {
            sendLog('error', `Unhandled Rejection: ${event.reason}`, {
                reason: event.reason ? (event.reason.stack || event.reason) : 'unknown'
            });
        };

        // 3. Intercept console.error (Optional but useful for framework errors)
        console.error = function(...args) {
            // Call original first
            ORIGINAL_CONSOLE_ERROR.apply(console, args);
            
            // Format args
            const msg = args.map(a => 
                typeof a === 'object' ? (a.stack || JSON.stringify(a)) : String(a)
            ).join(' ');

            sendLog('error', msg, { type: 'console.error' });
        };
    })();
  </script>
  <script src="js/lucide-icons.js?v=1"></script>
  <script src="js/renderer.js?v=1027"></script>
  <script src="js/journey-viewer.js?v=4"></script>
  <script src="js/json-renderer.js"></script>
  <script>
    // ===========================================
    // State
    // ===========================================
    const state = {
      isStreaming: false,
      isConnected: false,
      conversationHistory: [],
      sessionConfig: {},
      currentView: 'map' // 'map' or 'json'
    };

    // Toggle View
    function toggleView() {
        state.currentView = state.currentView === 'map' ? 'json' : 'map';
        
        if (state.currentView === 'json') {
            if (window.journeyViewer) window.journeyViewer.pause();
            var cv = document.getElementById(window.journeyViewer ? window.journeyViewer.canvasId : '');
            if (cv) cv.classList.add('json-view-mode');
        } else {
            if (window.journeyViewer) window.journeyViewer.resume();
            var cv2 = document.getElementById(window.journeyViewer ? window.journeyViewer.canvasId : '');
            if (cv2) cv2.classList.remove('json-view-mode');
        }

        if (currentJourney) {
            renderCurrentView();
        }
    }

    function renderCurrentView() {
        if (!currentJourney) return;
        
        if (state.currentView === 'map') {
            // During streaming, render directly (no auto-fit).
            // journeyRendered event handles fit logic separately.
            renderMap(currentJourney);
        } else {
            renderJson(currentJourney);
        }
    }

    // ===========================================
    // JourneyViewer Setup (singleton)
    // ===========================================
    window.journeyViewer = null;

    document.addEventListener('DOMContentLoaded', () => {
        window.journeyViewer = JourneyViewer.init('journeyViewerRoot', {
            showDebugGen: true,
            showTranscript: false,
            showPdf: true,
            onDebugGen: function () { debugGenerateRandom(); },
            onPdf: function () { exportToPdf(); }
        });

        // GEN button: hidden by default, shown only for superadmin after auth
        window.journeyViewer.hideButton('jv-gen');

        // Backward compat: expose panzoomInstance for any remaining refs
        Object.defineProperty(window, 'panzoomInstance', {
            get: function () { return window.journeyViewer ? window.journeyViewer.panzoom : null; }
        });

        // Seed canvas with empty "New Journey" board
        renderMap({
            name: 'New Journey',
            role: '',
            userName: '',
            phases: [],
            swimlanes: [],
            cells: [],
            quotes: []
        });
        setTimeout(function () { window.journeyViewer.fit(); }, 150);
    });

    // Convenience wrappers for code that still calls these
    function performFit() { if (window.journeyViewer) window.journeyViewer.fit(); }
    function panzoomAction(action) {
        if (!window.journeyViewer) return;
        if (action === 'zoomIn') window.journeyViewer.zoomIn();
        else if (action === 'zoomOut') window.journeyViewer.zoomOut();
        else if (action === 'fit') window.journeyViewer.fit();
    }

    let hasAutoFitComplete = false;
    let lastRenderedWidth = 0;
    let lastRenderedHeight = 0;

    // Listen for render events from renderer.js
    window.addEventListener('journeyRendered', (e) => {
        const { width, height } = e.detail;
        const hasSizeChanged = Math.abs(width - lastRenderedWidth) > 50 ||
                              Math.abs(height - lastRenderedHeight) > 50;
        const isComplete = currentJourney &&
                          (currentJourney.stage === 'COMPLETE' ||
                           currentJourney.status === 'READY_FOR_REVIEW' ||
                           document.body.classList.contains('journey-complete'));

        lastRenderedWidth = width;
        lastRenderedHeight = height;

        if (hasSizeChanged || (isComplete && !hasAutoFitComplete)) {
            document.fonts.ready.then(() => {
                if (isComplete) {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            performFit();
                            hasAutoFitComplete = true;
                        });
                    });
                } else {
                    requestAnimationFrame(() => performFit());
                }
            });
        }
    });

    // Load History from LocalStorage
    function loadHistory() {
        const stored = localStorage.getItem('max_chat_history');
        if (stored) {
            try {
                const parsed = JSON.parse(stored);
                // Filter out system start messages just in case
                state.conversationHistory = parsed.filter(m => m.content !== "START_SESSION");
                
                // Re-render messages
                messagesArea.innerHTML = ''; // Clear existing (like loading msg)
                state.conversationHistory.forEach(msg => {
                    addMessage(msg.content, msg.role === 'assistant' || msg.role === 'model' ? 'ai' : 'user');
                });
                
                // Scroll to bottom
                setTimeout(() => messagesArea.scrollTop = messagesArea.scrollHeight, 100);
            } catch (e) {
                console.error("Failed to load history", e);
            }
        }
    }

    function saveHistory() {
        localStorage.setItem('max_chat_history', JSON.stringify(state.conversationHistory));
    }

    function clearHistory() {
        localStorage.removeItem('max_chat_history');
        state.conversationHistory = [];
        messagesArea.innerHTML = '';
    }

    // ===========================================
    // DOM Elements
    // ===========================================
    const messagesArea = document.getElementById('messagesArea');
    const chatInput = document.getElementById('chatInput');
    const sendButton = document.getElementById('sendButton');
    const inputWrapper = document.getElementById('inputWrapper');
    // journeyDashboard is created dynamically by JourneyViewer — use getter
    function getJourneyDashboard() {
        if (window.journeyViewer) return document.getElementById(window.journeyViewer.canvasId);
        return document.getElementById('journeyViewerRoot_cv');
    }
    let currentJourneyId = null;
    let currentJourney = null; // Store full object
    let lastJourneyVersion = 0;

    // ===========================================
    // Journey Visualization (Polling)
    // ===========================================
    async function pollJourneyState() {
      if (!currentJourneyId) return;

      // Skip polling for client-side debug journeys
      if (currentJourneyId.startsWith('debug-')) return;

      try {
        const response = await fetch(`/api/journey-state/${currentJourneyId}`);
        if (!response.ok) return;
        
        const journey = await response.json();
        
        if (journey) {
          lastJourneyVersion = journey.version;
          // Inject template icon from session config so canvas renderer can use it
          if (state.sessionConfig && state.sessionConfig.templateIcon) {
              journey.templateIcon = state.sessionConfig.templateIcon;
          }
          currentJourney = journey; // Update global state
          renderCurrentView();
        }
      } catch (e) {
        console.error("Polling error", e);
      }
    }

    // Poll every 2 seconds
    setInterval(pollJourneyState, 2000);

    // Initial Poll
    pollJourneyState();

    // Modal Logic
    // (Handled by renderer.js)


    // Capture Journey ID from AI responses (simple heuristic for prototype)
    // In a real app, the backend would send this in the metadata
    function checkForJourneyId(text) {
        // This is a hack for the prototype. Ideally the AI driver sends a structured event.
        // We'll rely on the fact that we can just query the *latest* journey for this demo
        // Or hardcode the ID if the AI mentions it. 
        // Better yet, let's just fetch the list and grab the most recent one for now.
        fetchLatestJourney();
    }

    async function fetchLatestJourney() {
        try {
             // We need a list endpoint, but Store.list exists in code. 
             // Let's assume we can hit GET /v1/journey-maps (if we implemented list)
             // Since we didn't expose list in API, we'll just check if we have one in local storage or 
             // wait for the AI to "create" one and we'll sniff it.
             
             // WORKAROUND: The driver (server.js) should return the journey ID.
             // For now, let's poll a "debug" endpoint or similar. 
             // Actually, let's just rely on the user to paste it or the AI to say it? No, that's bad UX.
             
             // Real Fix: I'll update the server.js to return the journeyId in the chat response metadata.
        } catch(e) {}
    }

    // ===========================================
    // Connection Check
    // ===========================================
    async function checkConnection() {
      try {
        const response = await fetch('/api/health');
        const data = await response.json();
        
        if (data.status === 'ok') {
          state.isConnected = true;
          // Update mobile hamburger model label
          const mobileLabel = document.getElementById('mobileModelName');
          if (mobileLabel) mobileLabel.textContent = data.model || 'Connected';
        }
      } catch (error) {
        state.isConnected = false;
        const mobileLabel = document.getElementById('mobileModelName');
        if (mobileLabel) mobileLabel.textContent = 'Not connected';
      }
    }

    // Check connection on load
    checkConnection();

    // ===========================================
    // URL Parameter Handling
    // ===========================================
    async function checkUrlParams() {
      const params = new URLSearchParams(window.location.search);
      
      // 1. Check for Config ID (Short Link)
      const configId = params.get('id') || params.get('config');
      let remoteConfig = {};

      if (configId) {
          try {
              const res = await fetch(`/api/links/${configId}?_t=${Date.now()}`);
              if (res.ok) {
                  const linkData = await res.json();
                  // If toggles exist, only include fields whose toggles are ON.
                  // If no toggles (legacy config), include any field that has a value.
                  const hasToggles = linkData.toggles && Object.keys(linkData.toggles).length > 0;
                  const t = linkData.toggles || {};
                  const use = (key, val) => hasToggles ? (t[key] ? val : undefined) : (val || undefined);
                  remoteConfig = {
                      name: use('name', linkData.name),
                      role: use('role', linkData.role),
                      journeyName: use('journey', linkData.journey),
                      welcomePrompt: use('welcomePrompt', linkData.welcomePrompt),
                      journeyPrompt: use('journeyPrompt', linkData.journeyPrompt),
                      ragContext: use('ragContext', linkData.ragContext) || null,
                      personaFrame: use('personaFrame', linkData.personaFrame) || null,
                      personaLanguage: use('personaLanguage', linkData.personaLanguage) || null,
                      swimlanes: use('swimlanes', linkData.swimlanes),
                      phases: use('phases', linkData.phases),
                      requireAuth: !!linkData.requireAuth,
                      templateId: linkData.id,
                      templateIcon: linkData.icon || null
                  };

                  // Set header template icon (white) and template title (red, uppercase)
                  const headerIcon = document.getElementById('headerTemplateIcon');
                  if (headerIcon) headerIcon.innerHTML = getPickerIconSvg(linkData.icon || 'file-text', 24);
                  const headerName = document.getElementById('headerTemplateName');
                  const templateTitle = linkData.configName || linkData.journey || '';
                  if (headerName && templateTitle) {
                      headerName.textContent = templateTitle;
                  }
                  // Hide logo whenever a template is loaded (icon replaces it)
                  const logoImg = document.getElementById('headerLogoImg');
                  if (logoImg) logoImg.style.display = 'none';
              }
          } catch (e) {
              console.error("Error fetching config:", e);
          }
      }

      // No default header icon when no template is loaded

      // 2. Check URL first, then LocalStorage
      const journeyId = params.get('journeyId') || localStorage.getItem('max_journey_id');
      
      if (journeyId) {
          currentJourneyId = journeyId;
          localStorage.setItem('max_journey_id', journeyId);
          pollJourneyState();
      }

      // 3. Capture Context (Merge Remote + URL Params)
      // URL params take precedence over remote config
      
      // Parse URL swimlanes if present
      const urlSwimlanes = (() => {
        try {
            const s = params.get('swimlanes');
            return s ? JSON.parse(decodeURIComponent(s)) : null;
        } catch (e) { console.error('Failed to parse swimlanes', e); return null; }
      })();

      // Parse URL phases if present
      const urlPhases = (() => {
        try {
            const p = params.get('phases');
            return p ? JSON.parse(decodeURIComponent(p)) : null;
        } catch (e) { console.error('Failed to parse phases', e); return null; }
      })();

      state.sessionConfig = {
          name: params.get('name') || remoteConfig.name,
          role: params.get('role') || remoteConfig.role,
          journeyName: params.get('journey') || remoteConfig.journeyName,
          welcomePrompt: params.get('welcome-prompt') || remoteConfig.welcomePrompt,
          journeyPrompt: params.get('journey-prompt') || remoteConfig.journeyPrompt,
          ragContext: remoteConfig.ragContext || null,
          personaFrame: remoteConfig.personaFrame || null,
          personaLanguage: remoteConfig.personaLanguage || null,
          swimlanes: urlSwimlanes || remoteConfig.swimlanes,
          phases: urlPhases || remoteConfig.phases,
          journeyId: journeyId,
          templateId: remoteConfig.templateId || null,
          templateIcon: remoteConfig.templateIcon || null,
          requireAuth: remoteConfig.requireAuth || false
      };

      // Clean up undefined/null values
      Object.keys(state.sessionConfig).forEach(key => 
          state.sessionConfig[key] === null && delete state.sessionConfig[key]
      );

      // Log config for debugging
      console.log("[DEBUG] Session Config:", state.sessionConfig);
      // Send to backend logger to verify what user is sending
      if (typeof sendLog === 'function') {
          sendLog('info', 'Session Config Initialized', { 
              config: state.sessionConfig,
              hasWelcome: !!state.sessionConfig.welcomePrompt
          });
      }

      // Trigger AI Welcome if params exist (but only if we don't have a journeyId already loaded)
      // If we loaded a journeyId, the user likely wants to see the map first, 
      // OR continue the chat. 
      
      // Load History First
      loadHistory();

      // Decision: Only start conversation if history is empty AND no journey ID is present
      // If history exists, we resume. If journey ID exists, we resume context.
      
      // If we have URL params but NO journey ID, we must start a NEW conversation to apply those params.
      // The issue was that sometimes it would load history, see it's empty, but then not start.
      // OR it would see a journeyId in local storage (even if we wanted to reset).
      
      if (!journeyId && state.conversationHistory.length === 0) {
          // Check if this template requires auth
          if (state.sessionConfig.requireAuth) {
              // Show auth gate instead of starting conversation directly
              setTimeout(() => showAuthGate(), 300);
          } else {
              // Add a small delay to ensure everything is initialized
              setTimeout(() => startConversation(), 500);
          }
      }
    }
    
    function startConversation() {
        // Send a hidden "system start" signal
        // We don't add this to the UI history as a user message
        sendMessage(true); 
    }
    
    // Check for params after a brief delay to ensure DOM is ready
    setTimeout(checkUrlParams, 100);

    // ===========================================
    // Settings Handling
    // ===========================================
    async function fetchSettings() {
        try {
            const response = await fetch('/api/settings');
            if (response.ok) {
                const settings = await response.json();
                if (settings.agentName) {
                    updateAgentName(settings.agentName);
                }
            }
        } catch (e) {
            console.error("Failed to fetch settings", e);
        }
    }

    function updateAgentName(name) {
        // Update Title
        document.title = name;
        
        // Update Meta Description
        document.querySelector('meta[name="description"]').setAttribute('content', `${name} - AI Assistant`);
        
        // Update Placeholder
        const chatInput = document.getElementById('chatInput');
        chatInput.placeholder = `Message ${name}...`;
    }

    // Fetch settings on load
    fetchSettings();

    // ===========================================
    // Input Handling
    // ===========================================
    function autoResize(el) {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 150) + 'px';
    }

    function toggleSendButton() {
      sendButton.disabled = !chatInput.value.trim() || state.isStreaming;
    }

    function handleKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function useSuggestion(text) {
      chatInput.value = text;
      autoResize(chatInput);
      toggleSendButton();
      chatInput.focus();
    }

    function setInputEnabled(enabled) {
      if (enabled) {
        inputWrapper.classList.remove('disabled');
        chatInput.disabled = false;
      } else {
        inputWrapper.classList.add('disabled');
        chatInput.disabled = true;
      }
      toggleSendButton();
    }

    // ===========================================
    // Typing Indicator
    // ===========================================
    function getDisplayName(type) {
        if (type === 'ai') {
            return (state.sessionConfig.agentName || 'MAX').toUpperCase();
        } else {
            // User
            let name = state.sessionConfig.name;
            if (!name && currentJourney && currentJourney.userName) {
                name = currentJourney.userName;
            }
            if (name) {
                return name.split(' ')[0].toUpperCase();
            }
            return 'YOU';
        }
    }

    function showTypingIndicator() {
      if (document.getElementById('typingIndicator')) return;

      const typingDiv = document.createElement('div');
      typingDiv.className = 'max-typing';
      typingDiv.id = 'typingIndicator';
      
      const name = getDisplayName('ai');

      typingDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-typing-dots">
          <div class="max-typing-dot"></div>
          <div class="max-typing-dot"></div>
          <div class="max-typing-dot"></div>
        </div>
      `;

      messagesArea.appendChild(typingDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    function removeTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      if (indicator) {
        indicator.remove();
      }
    }

    // ===========================================
    // Message Handling
    // ===========================================
    async function sendMessage(isSystemStart = false) {
      let text = '';
      
      if (isSystemStart) {
          // Special signal text that won't be shown to user but triggers the backend
          text = "START_SESSION"; 
      } else {
          text = chatInput.value.trim();
          if (!text || state.isStreaming) return;
      }

      // Add user message ONLY if it's not a system start
      if (!isSystemStart) {
          addMessage(text, 'user');
          state.conversationHistory.push({ 
              role: 'user', 
              content: text,
              timestamp: new Date().toISOString()
          });
          saveHistory(); // Save
          
          // Clear input
          chatInput.value = '';
          chatInput.style.height = 'auto';
          toggleSendButton();
      }

      // Disable input while streaming
      state.isStreaming = true;
      setInputEnabled(false);

      // Show typing indicator immediately
      showTypingIndicator();

      // We will create the AI message bubble only when text actually arrives
      let aiMessageEl = null;
      let bubbleEl = null;

      try {
        // Start streaming request
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            history: state.conversationHistory.filter(h => h.content !== "START_SESSION"), // Don't send START_SESSION in history if it lingered
            config: state.sessionConfig, // Pass the context/config
            journeyId: currentJourneyId // Pass the ID so the model doesn't lose track
          })
        });

        if (!response.ok) {
          throw new Error('Failed to connect to server');
        }

        // Read SSE stream
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.error) {
                  throw new Error(data.error);
                }
                
                // If we get text and haven't created the bubble yet, do it now
                if (data.text) {
                  if (!aiMessageEl) {
                      removeTypingIndicator();
                      aiMessageEl = createStreamingMessage();
                      bubbleEl = aiMessageEl.querySelector('.max-message-bubble');
                  }
                  
                  fullResponse += data.text;
                  bubbleEl.innerHTML = formatMessage(fullResponse) + '<span class="streaming-cursor"></span>';
                  messagesArea.scrollTop = messagesArea.scrollHeight;
                }
                
                if (data.done) {
                  // If we finished but never got text (e.g. pure tool call?), ensure typing is gone
                  if (!aiMessageEl) removeTypingIndicator();
                  
                  if (aiMessageEl) {
                      // Remove cursor, finalize message
                      bubbleEl.innerHTML = formatMessage(fullResponse);
                      addMessageActions(aiMessageEl);
                      state.conversationHistory.push({ 
                          role: 'assistant', 
                          content: fullResponse,
                          timestamp: new Date().toISOString()
                      });
                      saveHistory(); // Save
                  }
                  
                  if (data.journeyId) {
                      currentJourneyId = data.journeyId;
                      localStorage.setItem('max_journey_id', currentJourneyId);
                      // Trigger immediate poll
                      pollJourneyState();
                  }
                }
              } catch (e) {
                // Skip malformed JSON
                if (e.message !== 'Unexpected end of JSON input') {
                  throw e;
                }
              }
            }
          }
        }

      } catch (error) {
        console.error('Streaming error:', error);
        removeTypingIndicator();
        
        // Show error message
        if (!aiMessageEl) {
            aiMessageEl = createStreamingMessage();
            bubbleEl = aiMessageEl.querySelector('.max-message-bubble');
        }
        
        bubbleEl.innerHTML = `<p>Sorry, I encountered an error: ${escapeHtml(error.message)}</p>
                             <p>Please make sure the server is running and try again.</p>`;
        aiMessageEl.classList.add('max-message--error');
      }

      // Re-enable input
      state.isStreaming = false;
      setInputEnabled(true);
      chatInput.focus();
    }

    // Create message element for streaming
    function createStreamingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'max-message max-message--ai';
      
      const name = getDisplayName('ai');

      messageDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-message-content">
          <div class="max-message-bubble">
            <span class="streaming-cursor"></span>
          </div>
        </div>
      `;

      messagesArea.appendChild(messageDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
      
      return messageDiv;
    }

    // Add actions to message after streaming completes
    function addMessageActions(messageEl) {
      const contentEl = messageEl.querySelector('.max-message-content');
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'max-message-actions';
      actionsDiv.innerHTML = `
        <button class="max-message-action" onclick="copyMessage(this)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy
        </button>
      `;
      contentEl.appendChild(actionsDiv);
    }

    // Add static message (user messages)
    function addMessage(content, type) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `max-message max-message--${type}`;
      
      const name = getDisplayName(type);

      messageDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-message-content">
          <div class="max-message-bubble">${type === 'ai' ? formatMessage(content) : escapeHtml(content)}</div>
        </div>
      `;

      messagesArea.appendChild(messageDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    // ===========================================
    // Formatting Helpers
    // ===========================================
    function _legacy_escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function _legacy_formatMessage(text) {
      // Basic markdown-like formatting
      let formatted = escapeHtml(text);
      
      // Code blocks
      formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
      
      // Inline code
      formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
      
      // Headers (###)
      formatted = formatted.replace(/^###\s+(.*$)/gm, '<h3>$1</h3>');
      
      // Bold
      formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      
      // Italic
      formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      
      // Line breaks to paragraphs
      formatted = formatted
        .split(/\n\n+/)
        .map(para => para.trim())
        .filter(para => para)
        .map(para => {
          // Check if it's a list
          if (para.match(/^[-*•]\s/m)) {
            const items = para.split(/\n/).map(item => 
              `<li>${item.replace(/^[-*•]\s*/, '')}</li>`
            ).join('');
            return `<ul>${items}</ul>`;
          }
          // Check if it's a numbered list
          if (para.match(/^\d+\.\s/m)) {
            const items = para.split(/\n/).map(item => 
              `<li>${item.replace(/^\d+\.\s*/, '')}</li>`
            ).join('');
            return `<ol>${items}</ol>`;
          }
          return `<p>${para.replace(/\n/g, '<br>')}</p>`;
        })
        .join('');
      
      return formatted;
    }

    // Copy message content
    function copyMessage(btn) {
      const bubble = btn.closest('.max-message-content').querySelector('.max-message-bubble');
      navigator.clipboard.writeText(bubble.innerText);
      btn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"/>
        </svg>
        Copied!
      `;
      setTimeout(() => {
        btn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy
        `;
      }, 2000);
    }

    // Download Full Transcript as Markdown
    function downloadTranscript() {
        if (!state.conversationHistory || state.conversationHistory.length === 0) {
            alert("No conversation history to download.");
            return;
        }

        const date = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
        const time = new Date().toLocaleTimeString('en-US');
        const journeyName = currentJourney ? currentJourney.name : (state.sessionConfig.journeyName || 'Untitled Journey');
        const userName = state.sessionConfig.name || (currentJourney ? currentJourney.userName : 'User');
        const agentName = state.sessionConfig.agentName || 'MAX';

        let md = `# Journey Map Transcript\n\n`;
        md += `**Date:** ${date} at ${time}\n`;
        md += `**Journey:** ${journeyName}\n`;
        md += `**User:** ${userName}\n`;
        md += `**Agent:** ${agentName}\n`;
        md += `\n---\n\n`;

        state.conversationHistory.forEach(msg => {
            const role = msg.role === 'user' ? userName.toUpperCase() : agentName.toUpperCase();
            const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '';
            const header = timestamp ? `### ${role} [${timestamp}]` : `### ${role}`;
            
            md += `${header}\n\n`;
            md += `${msg.content}\n\n`;
        });

        md += `\n---\n*Generated by M.AX Journey Mapper*`;

        // Create Blob and Download
        const blob = new Blob([md], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `transcript-${journeyName.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${Date.now()}.md`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Export to PDF (Canvas + Transcript)
async function exportToPdf() {
    if (!currentRenderedJourney) return;

    const element = document.querySelector('.journey-board-container');
    if (!element) return;
    
    // Ensure fonts are embedded
    if (typeof embedFontsForPdf === 'function') {
        await embedFontsForPdf();
    }

    const parent = getJourneyDashboard();
    const originalTransform = parent ? parent.style.transform : '';
    if (parent) parent.style.transform = 'none'; 
    
    // Rasterize SVGs before capture
    let svgOriginals = [];
    if (typeof rasterizeSvgImages === 'function') {
        svgOriginals = await rasterizeSvgImages(element);
    }

    try {
        // ── PAGE 1: Journey Canvas ──
        const canvasEl = await html2canvas(element, {
            scale: 2,
            useCORS: true,
            backgroundColor: '#0a0c10',
            logging: false,
            windowWidth: element.scrollWidth,
            windowHeight: element.scrollHeight
        });

        const canvasImg = canvasEl.toDataURL('image/jpeg', 0.98);
        const { jsPDF } = window.jspdf;
        
        const cw = canvasEl.width;
        const ch = canvasEl.height;
        
        const pdf = new jsPDF({
            orientation: cw > ch ? 'landscape' : 'portrait',
            unit: 'px',
            format: [cw, ch]
        });
        pdf.addImage(canvasImg, 'JPEG', 0, 0, cw, ch);

        // ── TRANSCRIPT PAGES ──
        if (state.conversationHistory && state.conversationHistory.length > 0) {
            // Build transcript header info
            const journey = currentRenderedJourney;
            const templateIcon = journey.templateIcon || null;
            const journeyName = escapeHtml(journey.name || state.sessionConfig.journeyName || 'Untitled Journey');
            const userName = journey.userName || state.sessionConfig.name || '';
            const userRole = journey.role || state.sessionConfig.role || '';
            const agentName = (state.sessionConfig.agentName || 'MAX').toUpperCase();

            // Build Lucide icon SVG from LUCIDE_ICONS dict
            let iconSvg = '';
            if (templateIcon) {
                const lib = (typeof LUCIDE_ICONS !== 'undefined') ? LUCIDE_ICONS : {};
                const paths = lib[templateIcon] || null;
                if (paths) {
                    iconSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink:0; margin-right:12px;">' + paths + '</svg>';
                }
            }

            // Fixed transcript page width (match canvas or use sensible default)
            const pageW = Math.max(cw, 2400);
            const pageH = Math.round(pageW * 1.414); // ~A4 ratio

            // Build offscreen transcript HTML
            const transcriptDiv = document.createElement('div');
            transcriptDiv.style.cssText = 'position:absolute; left:-99999px; top:0; width:' + (pageW / 2) + 'px; background:#000000; color:#ffffff; font-family:var(--max-font-family-mono, "Messina Sans Mono", monospace); font-size:16px; line-height:1.7; padding:80px;';

            let html = '';
            // Header: Logo
            html += '<div style="margin-bottom:40px;"><img src="/max_header.svg" style="height:48px; width:auto; display:block;" alt="M.AX"></div>';
            // Header: Icon + Journey Name
            html += '<div style="display:flex; align-items:center; margin-bottom:16px;">';
            html += iconSvg;
            html += '<span style="font-size:36px; font-weight:700; color:#ed2224;">' + journeyName + '</span>';
            html += '</div>';
            // Header: Name & Role
            if (userName || userRole) {
                html += '<div style="font-size:20px; color:rgba(255,255,255,0.6); margin-bottom:12px;">';
                if (userName) html += '<span style="font-weight:700; color:#ffffff;">' + escapeHtml(userName) + '</span>';
                if (userName && userRole) html += ', ';
                if (userRole) html += escapeHtml(userRole);
                html += '</div>';
            }
            // Divider
            html += '<div style="border-top:1px solid rgba(255,255,255,0.15); margin:32px 0;"></div>';
            // Section title
            html += '<div style="font-size:14px; font-weight:700; text-transform:uppercase; letter-spacing:0.1em; color:#ed2224; margin-bottom:32px;">Conversation Transcript</div>';

            // Messages
            state.conversationHistory.forEach(msg => {
                const isUser = msg.role === 'user';
                const roleName = isUser ? (userName ? userName.split(' ')[0].toUpperCase() : 'USER') : agentName;
                const roleColor = isUser ? '#ed2224' : 'rgba(255,255,255,0.45)';
                const ts = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString('en-US', { hour:'2-digit', minute:'2-digit' }) : '';

                html += '<div style="margin-bottom:28px;">';
                html += '<div style="font-size:12px; font-weight:700; text-transform:uppercase; letter-spacing:0.08em; color:' + roleColor + '; margin-bottom:6px;">' + escapeHtml(roleName);
                if (ts) html += ' <span style="color:rgba(255,255,255,0.25); font-weight:400;">' + ts + '</span>';
                html += '</div>';
                html += '<div style="color:rgba(255,255,255,0.88); white-space:pre-wrap; word-wrap:break-word;">' + escapeHtml(msg.content || '') + '</div>';
                html += '</div>';
            });

            // Footer
            html += '<div style="border-top:1px solid rgba(255,255,255,0.15); margin-top:40px; padding-top:24px; font-size:12px; color:rgba(255,255,255,0.3);">Generated by M.AX Journey Mapper</div>';

            transcriptDiv.innerHTML = html;
            document.body.appendChild(transcriptDiv);

            // Wait for images (logo) to load
            await new Promise(r => setTimeout(r, 300));

            // Rasterize SVG images inside transcript too
            let tSvgOrig = [];
            if (typeof rasterizeSvgImages === 'function') {
                tSvgOrig = await rasterizeSvgImages(transcriptDiv);
            }

            // Capture the full transcript as one tall image
            const tCanvas = await html2canvas(transcriptDiv, {
                scale: 2,
                useCORS: true,
                backgroundColor: '#000000',
                logging: false,
                windowWidth: transcriptDiv.scrollWidth,
                windowHeight: transcriptDiv.scrollHeight
            });

            // Restore SVGs and remove temp element
            if (typeof restoreSvgImages === 'function') restoreSvgImages(tSvgOrig);
            document.body.removeChild(transcriptDiv);

            // Split into pages
            const tw = tCanvas.width;
            const th = tCanvas.height;
            const tPageH = Math.round(tw * 1.414); // A4-ish ratio
            const numPages = Math.ceil(th / tPageH);

            for (let i = 0; i < numPages; i++) {
                pdf.addPage([tw, tPageH], 'portrait');

                // Slice this portion from the tall canvas
                const sliceY = i * tPageH;
                const sliceH = Math.min(tPageH, th - sliceY);

                const sliceCanvas = document.createElement('canvas');
                sliceCanvas.width = tw;
                sliceCanvas.height = tPageH;
                const ctx = sliceCanvas.getContext('2d');

                // Fill black background for the full page (last page may be partial)
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, tw, tPageH);

                // Draw the slice
                ctx.drawImage(tCanvas, 0, sliceY, tw, sliceH, 0, 0, tw, sliceH);

                const sliceImg = sliceCanvas.toDataURL('image/jpeg', 0.95);
                pdf.addImage(sliceImg, 'JPEG', 0, 0, tw, tPageH);
            }
        }

        const jName = (currentRenderedJourney.name || 'journey').replace(/[^a-z0-9]/gi, '-').toLowerCase();
        pdf.save(`${jName}-${new Date().toISOString().split('T')[0]}.pdf`);

    } catch (err) {
        console.error("PDF export failed:", err);
        alert("Export failed. See console for details.");
    } finally {
        if (typeof restoreSvgImages === 'function') restoreSvgImages(svgOriginals);
        if (parent) parent.style.transform = originalTransform;
    }
}

    // Export to Image (PNG)
    async function exportToImage() {
        const element = document.querySelector('.journey-board-container');
        if (!element) return;

        // Ensure fonts are embedded
        if (typeof embedFontsForPdf === 'function') {
            await embedFontsForPdf();
        }

        // 1. Reset Transform to ensure full capture (on parent)
        const parent = getJourneyDashboard();
        const originalTransform = parent ? parent.style.transform : '';
        if (parent) parent.style.transform = 'none'; 
        
        try {
            const canvas = await html2canvas(element, {
                scale: 2,
                useCORS: true,
                backgroundColor: '#0a0c10',
                logging: false,
                windowWidth: element.scrollWidth,
                windowHeight: element.scrollHeight
            });

            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = `journey-map-${new Date().toISOString().split('T')[0]}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
        } catch (err) {
            console.error("Image export failed:", err);
            alert("Export failed. See console for details.");
        } finally {
            parent.style.transform = originalTransform;
        }
    }

    // Reset / New Journey
    function startNewJourney() {
        // 1. Clear Local Storage History
        clearHistory(); 
        
        // 2. If we have a current journey ID, we should probably delete it from the backend 
        //    so it doesn't clutter the admin (optional, but requested "erase session")
        if (currentJourneyId) {
            // Fire and forget delete - we don't need to wait for it
            fetch(`/v1/journey-maps/${currentJourneyId}`, { method: 'DELETE' });
        }

        // 3. Clear Persistent ID
        localStorage.removeItem('max_journey_id'); 
        
        // 4. When resetting with URL params, we want to START FRESH, not resume.
        //    The issue is checkUrlParams might see a journeyId if we don't clear the URL.
        const url = new URL(window.location.href);
        url.searchParams.delete('journeyId');
        
        // 5. Hard Reload to ensure fresh state
        window.location.href = url.toString();
    }

    function hardReset() {
        if(confirm("Start over completely? This clears the current chat.")) {
            startNewJourney();
        }
    }

    // ========================================
    // Template Picker (uses full LUCIDE_ICONS from lucide-icons.js)
    // ========================================
    // Fallback default icon SVG if LUCIDE_ICONS hasn't loaded or icon not found
    const DEFAULT_ICON_SVG = '<path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M10 9H8"/><path d="M16 13H8"/><path d="M16 17H8"/>';

    function getPickerIconSvg(name, size = 18) {
        const lib = (typeof LUCIDE_ICONS !== 'undefined') ? LUCIDE_ICONS : {};
        const paths = lib[name] || DEFAULT_ICON_SVG;
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${paths}</svg>`;
    }

    let cachedTemplates = null;
    
    async function fetchGlobalTemplates() {
        try {
            const res = await fetch(`/api/templates?_t=${Date.now()}`);
            if (res.ok) {
                cachedTemplates = await res.json();
                return cachedTemplates;
            }
        } catch (e) {
            console.error('Failed to fetch templates:', e);
        }
        return [];
    }

    function openTemplatePicker() {
        const panel = document.getElementById('templatePickerPanel');
        const list = document.getElementById('templatePickerList');
        panel.style.display = 'flex';
        list.innerHTML = '<div class="template-picker-loading">Loading...</div>';

        fetchGlobalTemplates().then(templates => {
            if (!templates || templates.length === 0) {
                list.innerHTML = '<div class="template-picker-empty">No templates available</div>';
                return;
            }
            list.innerHTML = '';
            templates.forEach(t => {
                const item = document.createElement('div');
                item.className = 'template-picker-item';
                item.innerHTML = `
                    <div class="template-picker-icon">${getPickerIconSvg(t.icon || 'file-text')}</div>
                    <div class="template-picker-info">
                        <div class="template-picker-name">${escapeHtml(t.configName)}</div>
                        <div class="template-picker-desc">${escapeHtml(t.description || '')}</div>
                    </div>
                `;
                item.addEventListener('click', () => launchTemplate(t.id));
                list.appendChild(item);
            });
        });
    }

    function closeTemplatePicker() {
        document.getElementById('templatePickerPanel').style.display = 'none';
    }

    function launchTemplate(templateId) {
        // Clear current session and navigate to template
        clearHistory();
        if (currentJourneyId) {
            fetch(`/v1/journey-maps/${currentJourneyId}`, { method: 'DELETE' });
        }
        localStorage.removeItem('max_journey_id');
        window.location.href = `/?id=${encodeURIComponent(templateId)}`;
    }

    function startBlankJourney() {
        clearHistory();
        if (currentJourneyId) {
            fetch(`/v1/journey-maps/${currentJourneyId}`, { method: 'DELETE' });
        }
        localStorage.removeItem('max_journey_id');
        window.location.href = '/';
    }

    function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    // Wire up template picker button
    document.getElementById('templatePickerBtn').addEventListener('click', openTemplatePicker);
    
    // Close picker on outside click (with guard for mobile menu triggering it)
    let pickerJustOpened = false;
    const origOpenTemplatePicker = openTemplatePicker;
    openTemplatePicker = function() {
        pickerJustOpened = true;
        origOpenTemplatePicker();
        setTimeout(() => { pickerJustOpened = false; }, 300);
    };
    document.addEventListener('click', (e) => {
        if (pickerJustOpened) return;
        const panel = document.getElementById('templatePickerPanel');
        const btn = document.getElementById('templatePickerBtn');
        if (panel && panel.style.display !== 'none' && !panel.contains(e.target) && e.target !== btn) {
            panel.style.display = 'none';
        }
    });

    // ========================================
    // Mobile Hamburger Menu
    // ========================================
    function openMobileMenu() {
        document.getElementById('mobileMenu').classList.add('active');
    }
    function closeMobileMenu() {
        document.getElementById('mobileMenu').classList.remove('active');
    }
    document.getElementById('hamburgerBtn').addEventListener('click', openMobileMenu);
    // Close on backdrop click
    document.getElementById('mobileMenu').addEventListener('click', (e) => {
        if (e.target === document.getElementById('mobileMenu')) closeMobileMenu();
    });

    // ========================================
    // Placeholder Modals (Create / About)
    // ========================================
    function showPlaceholder(name) {
        alert(`${name} is coming soon!`);
    }

// ===========================================
    // Feedback Panel
    // ===========================================
    function openFeedbackPanel() {
        document.getElementById('feedbackPanel').style.display = 'flex';
        document.getElementById('feedbackText').value = '';
        document.getElementById('feedbackStatus').style.display = 'none';
        document.getElementById('feedbackSubmitBtn').disabled = false;
        document.getElementById('feedbackSubmitBtn').textContent = 'Submit Feedback';
    }

    function closeFeedbackPanel() {
        document.getElementById('feedbackPanel').style.display = 'none';
    }

    async function submitFeedback() {
        const text = document.getElementById('feedbackText').value.trim();
        if (!text) {
            document.getElementById('feedbackText').focus();
            return;
        }

        const btn = document.getElementById('feedbackSubmitBtn');
        const status = document.getElementById('feedbackStatus');
        btn.disabled = true;
        btn.textContent = 'Sending...';

        try {
            const payload = {
                text,
                messages: state.conversationHistory || [],
                journeyId: currentJourneyId || null,
                templateId: state.sessionConfig?.templateId || null,
                email: state.sessionConfig?.userEmail || null
            };

            const res = await fetch('/api/feedback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (res.ok) {
                status.textContent = 'Thank you for your feedback!';
                status.className = 'feedback-status success';
                status.style.display = 'block';
                setTimeout(closeFeedbackPanel, 2000);
            } else {
                throw new Error('Failed to submit');
            }
        } catch (e) {
            status.textContent = 'Failed to send feedback. Please try again.';
            status.className = 'feedback-status error';
            status.style.display = 'block';
            btn.disabled = false;
            btn.textContent = 'Submit Feedback';
        }
    }

    // Close feedback on backdrop click
    document.getElementById('feedbackPanel').addEventListener('click', (e) => {
        if (e.target === document.getElementById('feedbackPanel')) closeFeedbackPanel();
    });

    // ===========================================
    // ABOUT MODAL
    // ===========================================
    function openAboutModal() {
        document.getElementById('aboutModal').style.display = 'flex';
    }

    function closeAboutModal() {
        document.getElementById('aboutModal').style.display = 'none';
    }

    // Close about on backdrop click
    document.getElementById('aboutModal').addEventListener('click', (e) => {
        if (e.target === document.getElementById('aboutModal')) closeAboutModal();
    });

    // ========================================
    // Firebase Auth (for per-template auth gate)
    // ========================================
    const frontendFirebaseConfig = {
        apiKey: "AIzaSyA4kA1WHUfHAqznL-Us-d8-whjpkr_D4a0",
        authDomain: "journey-mapper-ai-8822.firebaseapp.com",
        projectId: "journey-mapper-ai-8822",
        storageBucket: "journey-mapper-ai-8822.firebasestorage.app",
        messagingSenderId: "98598658832",
        appId: "1:98598658832:web:a7199d2b48d46914167b95"
    };

    let frontendFirebaseApp = null;
    let frontendAuth = null;

    function initFrontendFirebase() {
        if (frontendFirebaseApp) return;
        // Check if Firebase was already initialized (by admin sharing same SDK)
        if (firebase.apps.length === 0) {
            frontendFirebaseApp = firebase.initializeApp(frontendFirebaseConfig);
        } else {
            frontendFirebaseApp = firebase.apps[0];
        }
        frontendAuth = firebase.auth();
    }

    async function showAuthGate() {
        initFrontendFirebase();
        const gate = document.getElementById('authGate');
        gate.style.display = 'flex';

        const signInBtn = document.getElementById('authGateSignInBtn');
        const errorEl = document.getElementById('authGateError');
        
        signInBtn.onclick = async () => {
            try {
                errorEl.style.display = 'none';
                signInBtn.disabled = true;
                signInBtn.textContent = 'Signing in...';
                
                const provider = new firebase.auth.GoogleAuthProvider();
                const result = await frontendAuth.signInWithPopup(provider);
                const email = result.user.email;
                
                // Store email in session config
                state.sessionConfig.userEmail = email;

                // Show GEN button for superadmin
                if (email === 'daniel@monumental-i.com' && window.journeyViewer) {
                    window.journeyViewer.showButton('jv-gen');
                }
                
                // Hide auth gate
                gate.style.display = 'none';
                
                // Now start the conversation
                if (state.conversationHistory.length === 0) {
                    startConversation();
                }
            } catch (err) {
                errorEl.textContent = err.message || 'Sign-in failed.';
                errorEl.style.display = 'block';
                signInBtn.disabled = false;
                signInBtn.innerHTML = `<svg width="18" height="18" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"/><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"/><path fill="#34A853" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"/><path fill="#FBBC05" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"/></svg> Sign in with Google`;
            }
        };
    }

    function toggleMobileView() {
        const btn = document.getElementById('mobileToggleBtn');
        // Always clear glow on interaction
        if (btn) btn.classList.remove('map-updated');

        document.body.classList.toggle('show-map');
        
        if (document.body.classList.contains('show-map')) {
            if (btn) btn.textContent = 'Chat';
            // Auto-fit when switching to map
            setTimeout(() => {
                if(window.panzoomInstance) performFit();
            }, 100);
        } else {
            if (btn) btn.textContent = 'Map';
        }
    }

    // Fullscreen Toggle
    function toggleFullscreen() {
        const doc = window.document;
        const docEl = doc.documentElement;

        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            if (requestFullScreen) {
                requestFullScreen.call(docEl);
            } else {
                // Fallback for Safari iOS if API not supported on element
                alert("To use fullscreen on iOS, tap the 'Share' button and select 'Add to Home Screen'.");
            }
        } else {
            if (cancelFullScreen) {
                cancelFullScreen.call(doc);
            }
        }
    }

    // ===========================================
    // DEBUG: Fit Debugger
    // ===========================================
    function debugFit() {
        const viewport = document.getElementById('journeyViewerRoot_vp');
        const dashboard = getJourneyDashboard();
        const container = document.querySelector('.journey-board-container');
        const pz = window.panzoomInstance;
        
        console.group("Fit Debugger");
        console.log("Panzoom Instance:", pz);
        console.log("Viewport:", viewport ? viewport.getBoundingClientRect() : 'null');
        console.log("Dashboard:", dashboard ? {
            scrollW: dashboard.scrollWidth,
            scrollH: dashboard.scrollHeight,
            offsetW: dashboard.offsetWidth,
            offsetH: dashboard.offsetHeight,
            rect: dashboard.getBoundingClientRect()
        } : 'null');
        console.log("Container:", container ? {
            offsetLeft: container.offsetLeft,
            offsetTop: container.offsetTop,
            offsetW: container.offsetWidth,
            offsetH: container.offsetHeight,
            rect: container.getBoundingClientRect()
        } : 'null');
        
        if (pz) {
            console.log("Current Scale:", pz.getScale());
            console.log("Current Pan:", pz.getPan());
        }
        console.groupEnd();
        
        alert("Check console for debug info");
    }

    // ===========================================
    // DEBUG: Random Journey Generator
    // ===========================================
    function debugGenerateRandom() {
        const phasesPool = ["Discovery", "Research", "Evaluation", "Purchase", "Implementation", "Onboarding", "Usage", "Expansion", "Renewal", "Advocacy"];
        const swimlanesPool = ["Doing", "Thinking", "Feeling", "Touchpoints", "Pain Points", "Opportunities", "Data", "Systems"];
        
        // Random Count
        const phaseCount = Math.floor(Math.random() * 8) + 4; // 4 to 12 phases
        const swimlaneCount = Math.floor(Math.random() * 4) + 3; // 3 to 6 swimlanes
        
        // Select random subset
        const phases = phasesPool.sort(() => 0.5 - Math.random()).slice(0, phaseCount);
        const swimlanes = swimlanesPool.sort(() => 0.5 - Math.random()).slice(0, swimlaneCount);
        
        // Build Objects
        const phaseObjs = phases.map((p, i) => ({ phaseId: `p${i}`, name: p, description: `Key phase covering ${p.toLowerCase()} activities and milestones.`, summary: `Summary for ${p}. Lorem ipsum dolor sit amet.` }));
        const swimlaneObjs = swimlanes.map((s, i) => ({ swimlaneId: `s${i}`, name: s, description: `Captures the ${s.toLowerCase()} dimension of the user experience.`, summary: `Summary for ${s}. Consectetur adipiscing elit.` }));
        
        const cells = [];
        phaseObjs.forEach(p => {
            swimlaneObjs.forEach(s => {
                if (Math.random() > 0.2) { // 80% chance of cell
                    cells.push({
                        cellId: `${p.phaseId}-${s.swimlaneId}`,
                        phaseId: p.phaseId,
                        swimlaneId: s.swimlaneId,
                        headline: `Action in ${p.name}`,
                        description: `User is ${s.name.toLowerCase()} something related to ${p.name.toLowerCase()}. This is a generated description to test layout width and height.`
                    });
                }
            });
        });
        
        const journey = {
            id: 'debug-' + Date.now(),
            name: "Generated Test Journey",
            role: "Test Persona",
            userName: "Debug User",
            status: "READY_FOR_REVIEW",
            stage: "COMPLETE",
            description: "This is a randomly generated journey map to test the layout, fixed widths, board container, and dot grid background.",
            phases: phaseObjs,
            swimlanes: swimlaneObjs,
            cells: cells,
            mentalModels: "1. Model Alpha: Users think linear.\n2. Model Beta: Users jump around.\n3. Model Gamma: Price is key.",
            summaryOfFindings: "Overall, the journey is fragmented. We need better cohesion in the purchase phase.",
            quotes: ["This is the absolute best test quote I have ever seen."],
            templateIcon: "activity"
        };
        
        currentJourney = journey;
        currentJourneyId = journey.id;
        
        // Render
        renderMap(journey);
        
        // Ensure buttons show
        document.body.classList.add('journey-complete');
        
        // Fit
        setTimeout(() => {
            if(window.panzoomInstance) {
                performFit();
            }
        }, 100);
        
        console.log("Generated Journey:", journey);
    }
  </script>
</body>
</html>
