<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="description" content="M.AX - AI Assistant">
  <meta name="theme-color" content="#0a0c10">
  <title>M.AX</title>
  <meta property="og:title" content="M.AX - Journey Mapping Assistant">
  <meta property="og:description" content="An intelligent AI assistant for creating detailed user journey maps.">
  <meta property="og:image" content="https://journey-mapper.monumental.ax/max_splash.png">
  <meta property="og:url" content="https://journey-mapper.monumental.ax/">
  <meta property="og:type" content="website">
  
  <!-- Fonts -->
  <style>
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Light.otf') format('opentype');
      font-weight: 300;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-LightItalic.otf') format('opentype');
      font-weight: 300;
      font-style: italic;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Regular.otf') format('opentype');
      font-weight: 400;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Italic.otf') format('opentype');
      font-weight: 400;
      font-style: italic;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Bold.otf') format('opentype');
      font-weight: 700;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-BoldItalic.otf') format('opentype');
      font-weight: 700;
      font-style: italic;
    }

    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Light.otf') format('opentype');
      font-weight: 300;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Book.otf') format('opentype');
      font-weight: 350; /* Fallback for Book */
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Regular.otf') format('opentype');
      font-weight: 400;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-SemiBold.otf') format('opentype');
      font-weight: 600;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Bold.otf') format('opentype');
      font-weight: 700;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Black.otf') format('opentype');
      font-weight: 900;
      font-style: normal;
    }
  </style>
  
  <style>
    /* ========================================
       CSS VARIABLES
       ======================================== */
    :root {
      --max-color-background: #0a0c10;
      --max-color-surface-primary: #12141a;
      --max-color-surface-secondary: #1a1d24;
      --max-color-surface-tertiary: #22262f;
      --max-color-surface-hover: #2a2f3a;
      
      --max-color-text-primary: #f0f2f5;
      --max-color-text-secondary: #9ca3b4;
      --max-color-text-tertiary: #6b7280;
      --max-color-text-inverse: #0a0c10;
      
      --max-color-border: #2a2f3a;
      --max-color-border-subtle: #1e2229;
      
      --max-color-accent: #ed2224;
      --max-color-accent-hover: #ff4d4f;
      --max-color-accent-subtle: rgba(237, 34, 36, 0.15);
      
      --max-color-error: #ef4444;
      --max-color-error-subtle: rgba(239, 68, 68, 0.15);
      
      --max-color-ai-gradient-start: #ed2224;
      --max-color-ai-gradient-end: #c41e20;
      
      --max-font-family: 'Messina Sans', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --max-font-family-mono: 'Messina Sans Mono', 'SF Mono', Monaco, monospace;
      --max-radius-small: 8px;
      --max-radius-medium: 12px;
      --max-radius-large: 16px;
      --max-radius-xlarge: 20px;
      --max-radius-full: 9999px;
      
      --max-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.3);
      --max-shadow-glow: 0 0 20px rgba(237, 34, 36, 0.3);
    }

    /* ========================================
       RESET & BASE
       ======================================== */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      height: 100dvh;
      overflow: hidden;
      /* iOS Safari specific fix to prevent bounce/overscroll */
      position: fixed;
      width: 100%;
    }

    body {
      font-family: var(--max-font-family);
      font-size: 15px;
      line-height: 1.5;
      color: var(--max-color-text-primary);
      background: var(--max-color-background);
      -webkit-font-smoothing: antialiased;
    }

    /* ========================================
       APP LAYOUT
       ======================================== */
    .max-app {
      display: flex;
      flex-direction: column;
      height: 100%;
      height: 100dvh;
      width: 100%;
      margin: 0 auto;
    }

    .max-main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* ========================================
       CHAT CANVAS (LEFT) - NOW RIGHT
       ======================================== */
    .max-chat-canvas {
      flex: 1 !important;
      width: auto !important;
      max-width: none !important;
      min-width: 0 !important;
      border-left: 1px solid var(--max-color-border-subtle);
      background: var(--max-color-surface-primary);
      display: flex;
      flex-direction: column;
      color: var(--max-color-text-tertiary);
      font-size: 14px;
      overflow: hidden;
      position: relative; /* For absolute controls */
    }

    /* Panzoom Wrapper */
    .panzoom-viewport {
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: grab;
      position: relative;
      /* Dot Grid Background on Viewport */
      background-color: var(--max-color-background);
      background-image: radial-gradient(var(--max-color-border) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    .panzoom-viewport:active {
      cursor: grabbing;
    }

    .journey-dashboard {
      padding: 80px; /* More padding for aesthetic */
      width: max-content; /* Allow growth */
      min-width: 100%;
      min-height: 100%;
      transform-origin: 0 0; /* Critical for Panzoom */
      position: relative; /* Ensure offsetParent for children */
    }

    /* Container for the Board Look */
    .journey-board-container {
        border: 1px solid var(--max-color-border);
        background: var(--max-color-surface-primary);
        padding: 60px;
        box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        border-radius: var(--max-radius-large);
        /* Ensure it wraps content tightly around the widest child (the table) */
        display: inline-block; 
        /* width is now set via JS style attribute based on phase count */
        box-sizing: border-box;
    }

    /* JSON View Override - Reset to standard scroll */
    .journey-dashboard.json-view-mode {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        cursor: text;
        transform: none !important; /* Force reset transforms if any */
    }
    
    /* Panzoom Controls Styling */
    .panzoom-controls {
        position: absolute;
        bottom: 24px;
        right: 24px;
        display: flex;
        gap: 8px;
        z-index: 100;
        background: var(--max-color-surface-secondary);
        padding: 6px;
        border-radius: var(--max-radius-medium);
        border: 1px solid var(--max-color-border);
        box-shadow: var(--max-shadow-soft);
        flex-wrap: wrap; /* Allow wrapping on small screens if needed */
        max-width: 90vw; /* Prevent overflow on mobile */
        justify-content: flex-end;
    }

    .panzoom-btn {
        height: 36px;
        padding: 0 12px; /* Text padding */
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: 1px solid transparent;
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-primary);
        cursor: pointer;
        transition: all 0.15s ease;
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        white-space: nowrap;
    }

    .panzoom-btn:hover {
        background: var(--max-color-surface-tertiary);
        border-color: var(--max-color-border-subtle);
    }

    .panzoom-btn svg {
        display: none; /* Hide icons in favor of text if present, or just use text */
    }

    .journey-header {
      margin-bottom: 24px;
      border-bottom: 1px solid var(--max-color-border-subtle);
      padding-bottom: 16px;
    }

    .journey-title {
      font-size: 48px; /* 2x Bigger */
      font-weight: 600;
      color: var(--max-color-accent);
      margin-bottom: 8px;
    }

    .journey-role {
      font-family: var(--max-font-family-mono);
      font-size: 14px;
      color: var(--max-color-text-primary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .context-card {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      padding: 16px;
      margin-bottom: 24px;
    }

    .context-card h3 {
      font-family: var(--max-font-family-mono);
      font-size: 14px;
      font-weight: 600;
      color: var(--max-color-text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .context-content {
      font-size: 14px;
      line-height: 1.6;
      color: var(--max-color-text-primary);
      white-space: normal;
    }

    .context-content ul, .context-content ol {
      margin-left: 20px;
      margin-bottom: 12px;
    }
    .context-content li {
      margin-bottom: 4px;
    }
    .context-content p {
      margin-bottom: 12px;
    }
    .context-content h3 {
      font-size: 16px;
      font-weight: 600;
      color: var(--max-color-text-primary);
      margin-top: 16px;
      margin-bottom: 8px;
    }
    .context-content strong {
      color: var(--max-color-text-primary);
      font-weight: 600;
    }

    /* Living Table */
    .journey-table {
      display: grid;
      gap: 20px; /* Increased gap for better separation */
      padding: 20px 0;
    }

    .phase-header {
      font-weight: 700;
      color: var(--max-color-text-primary);
      text-align: center;
      padding: 24px 16px;
      background: var(--max-color-surface-secondary);
      border-radius: var(--max-radius-medium);
      border: 1px solid var(--max-color-border);
      font-size: 30px;
      /* "Smart" Sticky look (visual hierarchy) */
      box-shadow: 0 4px 0 var(--max-color-border-subtle);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .swimlane-header {
      font-weight: 600;
      color: var(--max-color-text-secondary);
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: flex-start; /* Align to top of cells */
      padding-top: 24px; /* Match cell padding */
      padding-right: 24px;
      border-right: 2px solid var(--max-color-border); /* Keep the vertical divider */
      text-align: right;
      font-size: 28px;
    }

    .swimlane-name {
      color: var(--max-color-text-primary);
      margin-bottom: 8px;
    }

    .swimlane-desc {
      font-family: var(--max-font-family-mono);
      font-size: 16px;
      color: var(--max-color-text-tertiary);
      font-weight: 400;
      max-width: 100%;
      overflow: visible;
      text-overflow: clip;
      white-space: normal;
      line-height: 1.4;
    }

    .journey-cell {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      padding: 24px; /* More padding */
      min-height: 160px; /* Taller default */
      height: auto;
      transition: all 0.2s ease;
      cursor: default;
      position: relative;
      /* Card Look */
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .journey-cell:hover {
      border-color: var(--max-color-accent);
      transform: translateY(-2px);
      box-shadow: var(--max-shadow-soft);
      z-index: 1; /* Bring to front */
    }

    .journey-cell.empty {
      background: rgba(255,255,255,0.01);
      border-style: dashed;
      border-color: var(--max-color-border-subtle);
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
    }

    .journey-cell.complete {
      border-left: 4px solid #22c55e;
    }

    .cell-action {
      font-weight: 600;
      color: var(--max-color-text-primary);
      margin-bottom: 12px;
      font-size: 26px;
      line-height: 1.3;
    }

    .cell-context {
      font-family: var(--max-font-family-mono);
      font-size: 20px;
      color: var(--max-color-text-secondary);
      display: block;
      overflow: visible;
      white-space: normal;
      line-height: 1.6;
    }

    /* ========================================
       MOBILE VIEW
       ======================================== */
    .journey-mobile-list {
      display: none;
      flex-direction: column;
      gap: 32px;
    }

    .mobile-phase-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .mobile-phase-header {
      font-size: 18px;
      font-weight: 700;
      color: var(--max-color-accent);
      padding-bottom: 8px;
      border-bottom: 1px solid var(--max-color-border);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .mobile-card {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      padding: 16px;
      cursor: default; /* Changed from pointer */
    }
    
    .mobile-card-label {
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        color: var(--max-color-text-tertiary);
        margin-bottom: 8px;
        text-transform: uppercase;
        font-weight: 700;
    }

    /* Mobile Responsive Logic */
    @media (max-width: 768px) {
        .journey-table { display: none !important; }
        .journey-mobile-list { display: flex !important; }
        
        /* Hide logo in journey title on mobile */
        .journey-title svg { display: none !important; }
        
        /* Adjust layout */
        .max-chat-canvas {
            width: 100% !important;
            min-width: 0 !important;
        }
        
        /* Stack buttons on mobile */
        .action-area {
            flex-direction: column;
            align-items: stretch;
        }
        .action-area button {
            width: 100% !important;
        }
    }

    /* Modal / Detail View */
    .cell-detail-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 10;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .cell-detail-modal {
      background: var(--max-color-surface-primary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      padding: 24px;
      width: 80%;
      max-width: 500px;
      box-shadow: var(--max-shadow-glow);
    }

    /* ========================================
       HEADER
       ======================================== */
    .max-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid var(--max-color-border-subtle);
      flex-shrink: 0;
    }

    .max-logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .max-logo-icon {
      width: 36px;
      height: 36px;
      background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end));
      border-radius: var(--max-radius-small);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
    }

    .max-logo-icon svg {
      width: 20px;
      height: 20px;
    }

    .max-logo-text {
      font-family: var(--max-font-family);
      font-size: 20px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .max-logo-text span {
      color: var(--max-color-accent);
    }

    .max-status {
      font-family: var(--max-font-family-mono);
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--max-color-text-tertiary);
    }

    .max-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--max-color-text-tertiary);
    }

    .max-status-dot.connected {
      background: #22c55e;
    }

    .max-status-dot.error {
      background: var(--max-color-error);
    }

    /* ========================================
       CHAT CONTAINER (RIGHT)
       ======================================== */
    .max-chat-container {
      flex: 0 0 480px !important;
      width: 480px !important;
      max-width: 480px !important;
      min-width: 480px !important;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--max-color-background);
    }

    /* ========================================
       MESSAGES AREA
       ======================================== */
    .max-messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .max-messages::-webkit-scrollbar {
      width: 6px;
    }

    .max-messages::-webkit-scrollbar-track {
      background: transparent;
    }

    .max-messages::-webkit-scrollbar-thumb {
      background: var(--max-color-border);
      border-radius: var(--max-radius-full);
    }

    /* Welcome State */
    .max-welcome {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 20px;
    }

    .max-welcome-icon {
      width: 72px;
      height: 72px;
      background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end));
      border-radius: var(--max-radius-large);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
      box-shadow: var(--max-shadow-glow);
    }

    .max-welcome-icon svg {
      width: 36px;
      height: 36px;
      color: white;
    }

    .max-welcome h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 12px;
      letter-spacing: -0.02em;
    }

    .max-welcome p {
      font-size: 16px;
      color: var(--max-color-text-secondary);
      max-width: 400px;
      margin-bottom: 32px;
    }

    .max-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .max-suggestion {
      padding: 10px 16px;
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-full);
      color: var(--max-color-text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .max-suggestion:hover {
      background: var(--max-color-surface-hover);
      color: var(--max-color-text-primary);
      border-color: var(--max-color-accent);
    }

    /* ========================================
       MESSAGE BUBBLES
       ======================================== */
    .max-message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-width: 100%;
      animation: messageIn 0.3s ease;
    }

    @keyframes messageIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .max-message--user {
      align-items: flex-end;
    }

    .max-message-header {
      font-family: var(--max-font-family-mono);
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      line-height: 1;
      width: fit-content;
      letter-spacing: 0.05em;
    }

    .max-message--ai .max-message-header {
      background: var(--max-color-accent);
    }

    .max-message--user .max-message-header {
      background: var(--max-color-surface-tertiary);
      color: var(--max-color-text-secondary);
    }

    /* AI Bubble - Gray */
    .max-message--ai .max-message-bubble {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border-subtle);
      border-radius: var(--max-radius-medium);
      border-top-left-radius: 4px; /* Align with header */
    }

    /* User Bubble - Red */
    .max-message--user .max-message-bubble {
      background: var(--max-color-accent);
      color: white;
      border: 1px solid var(--max-color-accent); /* Match border to bg */
      border-radius: var(--max-radius-medium);
      border-top-right-radius: 4px;
      margin-left: auto;
    }

    .max-message-content {
      flex: 1;
      min-width: 0;
      max-width: 100%;
    }

    .max-message-bubble {
      padding: 14px 18px;
      line-height: 1.6;
    }

    .max-message--error .max-message-bubble {
      background: var(--max-color-error-subtle);
      border-color: var(--max-color-error);
      color: var(--max-color-error);
    }

    .max-message-bubble h3 {
      font-size: 16px;
      font-weight: 600;
      margin-top: 12px;
      margin-bottom: 8px;
      color: inherit;
    }

    .max-message-bubble p {
      margin-bottom: 12px;
    }

    .max-message-bubble p:last-child {
      margin-bottom: 0;
    }

    .max-message-bubble ul, .max-message-bubble ol {
      margin: 12px 0;
      padding-left: 20px;
    }

    .max-message-bubble li {
      margin-bottom: 6px;
    }

    .max-message-bubble code {
      background: var(--max-color-surface-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 13px;
      font-family: var(--max-font-family-mono);
    }

    .max-message-bubble pre {
      background: var(--max-color-surface-primary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-small);
      padding: 12px;
      margin: 12px 0;
      overflow-x: auto;
    }

    .max-message-bubble pre code {
      background: transparent;
      padding: 0;
    }

    /* Streaming cursor */
    .max-message-bubble .streaming-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: var(--max-color-accent);
      margin-left: 2px;
      animation: cursorBlink 1s step-end infinite;
      vertical-align: text-bottom;
    }

    @keyframes cursorBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .max-message-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .max-message:hover .max-message-actions {
      opacity: 1;
    }

    .max-message-action {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 6px 10px;
      background: transparent;
      border: none;
      border-radius: var(--max-radius-small);
      color: var(--max-color-text-tertiary);
      font-size: 11px;
      font-family: var(--max-font-family-mono);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .max-message-action:hover {
      background: var(--max-color-surface-tertiary);
      color: var(--max-color-text-secondary);
    }

    .max-message-action svg {
      width: 14px;
      height: 14px;
    }

    /* ========================================
       TYPING INDICATOR
       ======================================== */
    .max-typing {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-start;
      margin-bottom: 24px;
    }

    .max-typing-dots {
      display: flex;
      gap: 4px;
      padding: 16px 20px;
      background: var(--max-color-surface-secondary);
      border-radius: var(--max-radius-large);
      border-top-left-radius: 4px;
      border: 1px solid var(--max-color-border-subtle);
    }

    .max-typing-dot {
      width: 8px;
      height: 8px;
      background: var(--max-color-text-tertiary);
      border-radius: 50%;
      animation: typingBounce 1.4s ease-in-out infinite;
    }

    .max-typing-dot:nth-child(2) { animation-delay: 0.15s; }
    .max-typing-dot:nth-child(3) { animation-delay: 0.3s; }

    @keyframes typingBounce {
      0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
      }
      30% {
        transform: translateY(-8px);
        opacity: 1;
      }
    }

    /* ========================================
       INPUT AREA
       ======================================== */
    .max-input-area {
      padding: 16px 24px 24px;
      border-top: 1px solid var(--max-color-border-subtle);
    }

    .max-input-wrapper {
      display: flex;
      align-items: flex-end;
      gap: 12px;
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-xlarge);
      padding: 8px 8px 8px 20px;
      transition: all 0.2s ease;
    }

    .max-input-wrapper:focus-within {
      border-color: var(--max-color-accent);
      box-shadow: var(--max-shadow-glow);
    }

    .max-input-wrapper.disabled {
      opacity: 0.6;
      pointer-events: none;
    }

    .max-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: 15px;
      color: var(--max-color-text-primary);
      resize: none;
      max-height: 150px;
      min-height: 24px;
      line-height: 1.5;
      padding: 8px 0;
    }

    .max-input::placeholder {
      color: var(--max-color-text-tertiary);
    }

    .max-send-button {
      width: 44px;
      height: 44px;
      background: var(--max-color-accent);
      border: none;
      border-radius: var(--max-radius-medium);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .max-send-button:hover:not(:disabled) {
      background: var(--max-color-accent-hover);
      transform: scale(1.05);
    }

    .max-send-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .max-send-button svg {
      width: 20px;
      height: 20px;
    }

    .max-input-hint {
      font-family: var(--max-font-family-mono);
      text-align: center;
      font-size: 11px;
      color: var(--max-color-text-tertiary);
      margin-top: 10px;
    }

    .max-input-hint kbd {
      background: var(--max-color-surface-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: inherit;
    }

    /* ========================================
       COMPLETION STATE
       ======================================== */
    /* Hide Chat Container */
    body.journey-complete .max-chat-container {
      display: none !important;
    }
    
    /* Full Width Canvas */
    body.journey-complete .max-chat-canvas {
      flex: 0 0 100% !important;
      width: 100% !important;
      max-width: 100% !important;
      border-right: none;
    }

    /* Hide Mobile Toggle in Complete State */
    body.journey-complete .mobile-toggle-btn {
        display: none !important;
    }

    /* Also hide the toggle button container/status if desired, but user just said "gone on both mobile and desktop" */
    /* The header stays, but toggle button specifically: */
    
    /* Ensure proper reset of Panzoom on transition to complete */
    body.journey-complete .journey-dashboard {
        width: max-content; /* Ensure it can still pan/zoom properly */
        min-width: 100%;
    }

    /* Panzoom Controls Styling */
    .panzoom-controls {
        position: absolute;
        bottom: 24px;
        right: 24px;
        display: flex;
        gap: 8px;
        z-index: 100;
        background: var(--max-color-surface-secondary);
        padding: 6px;
        border-radius: var(--max-radius-medium);
        border: 1px solid var(--max-color-border);
        box-shadow: var(--max-shadow-soft);
        flex-wrap: wrap; /* Allow wrapping on small screens if needed */
        max-width: 90vw; /* Prevent overflow on mobile */
        justify-content: flex-end;
    }

    .panzoom-btn {
        height: 36px;
        padding: 0 12px; /* Text padding */
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: 1px solid transparent;
        border-radius: var(--max-radius-small);
        color: var(--max-color-text-primary);
        cursor: pointer;
        transition: all 0.15s ease;
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        white-space: nowrap;
    }

    .panzoom-btn:hover {
        background: var(--max-color-surface-tertiary);
        border-color: var(--max-color-border-subtle);
    }
    .mobile-toggle-btn {
      display: none;
      padding: 8px 16px;
      background: var(--max-color-surface-tertiary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      color: var(--max-color-text-primary);
      font-size: 13px;
      font-family: var(--max-font-family-mono);
      font-weight: 500;
      cursor: pointer;
      margin-right: 12px;
    }

    @media (max-width: 768px) {
      .max-main-content {
        flex-direction: column; /* Normal column, we toggle visibility */
      }
      .max-chat-canvas, .max-chat-container {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 100% !important;
        flex: 1 !important;
        height: 100%;
        border: none;
      }
      
      /* Toggle Logic */
      body:not(.show-map) .max-chat-canvas { display: none !important; }
      body.show-map .max-chat-container { display: none !important; }
      
      .mobile-toggle-btn { display: block; }
      
      /* Header adjustments */
      .max-header { padding: 12px 16px; }
      .max-logo-text { display: none; } /* Save space */
      
      /* Hide Model Name on Mobile */
      .desktop-only { display: none !important; }
    }

    /* Reset Button Style */
    .reset-btn {
        background: none;
        border: 1px solid var(--max-color-border);
        border-radius: 4px;
        color: var(--max-color-text-tertiary);
        cursor: pointer;
        padding: 4px 8px;
        margin-left: 8px;
        font-family: var(--max-font-family-mono);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: all 0.15s ease;
    }
    .reset-btn:hover {
        background: var(--max-color-surface-tertiary);
        color: var(--max-color-text-primary);
        border-color: var(--max-color-text-secondary);
    }

    /* ========================================
       PDF EXPORT STYLES
       ======================================== */
    .pdf-export-mode {
      --max-color-background: #ffffff !important;
      --max-color-surface-primary: #ffffff !important;
      --max-color-surface-secondary: #ffffff !important;
      --max-color-surface-tertiary: #f3f4f6 !important;
      
      --max-color-text-primary: #111827 !important;
      --max-color-text-secondary: #4b5563 !important;
      --max-color-text-tertiary: #6b7280 !important;
      
      --max-color-border: #e5e7eb !important;
      --max-color-border-subtle: #f3f4f6 !important;
      
      color: #000000 !important;
      background: #ffffff !important;
    }

    /* Force background colors for PDF generation */
    .pdf-export-mode .journey-cell {
        background: #ffffff !important;
        border: 1px solid #e5e7eb !important;
        color: #000 !important;
        break-inside: avoid;
        page-break-inside: avoid;
    }

    /* Page Break Helper */
    .html2pdf__page-break {
        page-break-before: always;
    }
  </style>
</head>
<body>
  <div class="max-app">
    
    <!-- Header -->
    <header class="max-header">
      <div class="max-logo" onclick="toggleView()" style="cursor: pointer;" title="Toggle View (Map/JSON)">
          <img src="max_header.svg" alt="M.AX" style="height: 32px; width: auto;">
      </div>
      <div class="max-status" id="connectionStatus">
        <button id="mobileToggleBtn" class="mobile-toggle-btn" onclick="toggleMobileView()">Map</button>
        <span class="max-status-dot" id="statusDot"></span>
        <span id="statusText" class="desktop-only">Connecting...</span>
        <button onclick="hardReset()" title="Reset Session" class="reset-btn">
            RESET
        </button>
      </div>
    </header>

    <div class="max-main-content">
      <!-- Chat Container (Left) -->
      <div class="max-chat-container">
        
        <!-- Messages Area -->
        <div class="max-messages" id="messagesArea">
        </div>

      <!-- Input Area -->
      <div class="max-input-area">
        <div class="max-input-wrapper" id="inputWrapper">
          <textarea 
            class="max-input" 
            id="chatInput"
            placeholder="Message M.AX..."
            rows="1"
            onkeydown="handleKeyDown(event)"
            oninput="autoResize(this); toggleSendButton()"
          ></textarea>
          <button class="max-send-button" id="sendButton" onclick="sendMessage()" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 2L11 13"/>
              <path d="M22 2L15 22L11 13L2 9L22 2Z"/>
            </svg>
          </button>
        </div>
        <div class="max-input-hint" style="display: none;">
          <kbd>Enter</kbd> to send Â· <kbd>Shift + Enter</kbd> for new line
        </div>
      </div>
    </div>

        <!-- Chat Canvas (Right) -->
      <div class="max-chat-canvas" id="chatCanvas">
        <!-- Panzoom Viewport -->
        <div id="panzoomViewport" class="panzoom-viewport">
            <!-- Canvas Content -->
            <div class="journey-dashboard" id="journeyDashboard">
               <div style="height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; opacity: 0.5; gap: 24px;">
                  <div style="width: 300px; height: 300px; background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end)); border-radius: 72px; display: flex; align-items: center; justify-content: center; box-shadow: var(--max-shadow-glow);">
                      <svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128.5 42.6" style="width: 180px; height: auto;">
                          <path d="M5.9,42.6c-1.5,0-2.7-.3-3.6-.9-.9-.6-1.5-1.4-1.8-2.3s-.5-1.9-.5-3V9.1C0,6.2.7,3.9,2.2,2.5,3.7,1,5.9.3,9,.3s3.7.2,4.8.7c1.2.5,2.1,1.3,2.8,2.3.7,1.1,1.2,2.4,1.7,4.1l.3,1.2c.7,2.2,1.2,4,1.6,5.6.4,1.6.7,3,1,4.4.3,1.3.5,2.6.6,3.9.2,1.3.3,2.6.4,4.1.1-1.5.3-2.9.4-4.1s.4-2.6.6-3.9c.3-1.3.6-2.8,1-4.4.4-1.6,1-3.5,1.6-5.6l.3-1.2c.5-1.7,1.1-3,1.8-4.1.7-1.1,1.6-1.8,2.8-2.3,1.2-.5,2.8-.7,4.8-.7,3.1,0,5.4.7,6.8,2.2,1.4,1.5,2.2,3.7,2.2,6.6v27.2c0,1-.2,2-.5,3s-.9,1.7-1.8,2.3-2.1.9-3.6.9-2.7-.3-3.6-.9c-.9-.6-1.5-1.4-1.8-2.3s-.5-1.9-.5-3v-4.9c0-2.7.2-5.7.4-9,.2-3.3.4-7.2.5-11.5l-5.2,19.4c-.4,1.3-.8,2.4-1.3,3.2-.4.8-1,1.4-1.8,1.8-.4-.8-.9-1.9-1.3-3.2l-5.2-19.4c.1,4.3.3,8.2.5,11.5s.3,6.4.4,9v4.9c0,1-.1,2-.4,3s-.9,1.7-1.8,2.3c-.9.6-2.1.9-3.6.9h0l.2.1Z" style="fill: #ffffff;"/>
                          <path d="M54.1,42.6c-.9,0-1.8-.2-2.8-.7s-1.7-1.2-2.4-2.1c-.6-.9-1-2-1-3.4s0-1.3.2-2.1c.1-.8.4-1.6.8-2.4l9.6-22.9c.6-1.5,1.2-2.9,1.7-4s1.1-2,1.7-2.8c.6-.7,1.4-1.3,2.4-1.6,1-.4,2.2-.5,3.8-.5s2.8.2,3.8.5c1,.4,1.8.9,2.4,1.6s1.2,1.7,1.7,2.8,1.1,2.4,1.7,4l9.6,22.9c.4.8.6,1.6.8,2.4.1.8.2,1.5.2,2.1,0,1.3-.3,2.5-1,3.4-.6.9-1.4,1.6-2.3,2.1s-1.9.7-2.8.7c-1.6,0-2.8-.3-3.7-1-.9-.7-1.6-1.6-2.1-2.7-.5-1.1-1-2.3-1.4-3.5l-1.3-4.2v-3.3c.1,0-3.8-10.1-3.8-10.1-.3-.8-.6-1.8-1-3s-.6-2.3-.9-3.2c-.2.9-.5,1.9-.9,3.2-.4,1.2-.7,2.2-1,3l-3.9,10.1v3.3c.1,0-1.2,4.2-1.2,4.2-.4,1.2-.8,2.4-1.3,3.5s-1.2,2-2.1,2.7-2.1,1-3.7,1h.2ZM59.2,33.1v-7.6h17.7v7.6h-17.7Z" style="fill: #ffffff;"/>
                          <path d="M97.8,42.6c-1.1,0-2.2-.3-3.2-.8s-1.9-1.3-2.5-2.3c-.7-1-1-2.2-1-3.7,0-1.9.5-3.5,1.6-4.7,1-1.2,2.4-2.5,4.1-3.9,1.2-.9,2.4-1.7,3.5-2.6,1.2-.9,2.3-1.8,3.5-2.7-.8-.7-1.9-1.6-3.2-2.7s-2.6-2.2-3.9-3.3c-1.7-1.4-3.1-2.8-4.1-4.1s-1.5-2.9-1.5-5c0-1.4.4-2.6,1-3.7.7-1,1.5-1.8,2.5-2.3,1-.5,2.1-.8,3.2-.8s2.5.3,3.4.8c.9.6,1.7,1.3,2.4,2.2s1.4,2,2,3.2c1,1.9,1.8,3.7,2.5,5.3s1.3,2.8,1.6,3.7c.3-.9.9-2.1,1.6-3.7.7-1.6,1.6-3.4,2.5-5.3.6-1.2,1.3-2.3,2-3.2.7-.9,1.5-1.7,2.4-2.2,1.1-.5,2.2-.8,3.5-.8s2.2.3,3.3.8c1,.5,1.9,1.3,2.5,2.4.7,1,1,2.2,1,3.7,0,2.1-.5,3.7-1.5,5-1,1.3-2.4,2.7-4.1,4.1-1.2,1-2.3,2-3.5,3s-2.3,2-3.5,2.9c.8.6,1.9,1.4,3.1,2.3,1.2,1,2.5,2,3.7,3,1.7,1.4,3.1,2.7,4.1,3.9,1,1.2,1.6,2.8,1.6,4.7s-.3,2.6-1,3.7c-.7,1-1.5,1.8-2.5,2.3s-2.1.8-3.3.8c-1.3,0-2.5-.3-3.4-.9-.9-.5-1.7-1.3-2.4-2.2-.7-1-1.4-2-2-3.2-.9-1.7-1.7-3.3-2.4-4.7-.8-1.4-1.3-2.7-1.7-3.7-.3,1-.9,2.3-1.7,3.7-.8,1.5-1.6,3-2.4,4.6-1,1.8-2,3.3-3.1,4.5s-2.7,1.8-4.7,1.8h0v.1Z" style="fill: #ffffff;"/>
                      </svg>
                  </div>
                  <h1 style="font-family: var(--max-font-family-mono); font-weight: 700; letter-spacing: 0.1em; color: var(--max-color-text-tertiary); margin-top: 16px; font-size: 14px;">JOURNEY MAP</h1>
               </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="panzoom-controls" id="panzoomControls">
            <button class="panzoom-btn" onclick="panzoomAction('zoomIn')" title="Zoom In">
                (+)
            </button>
            <button class="panzoom-btn" onclick="panzoomAction('zoomOut')" title="Zoom Out">
                (-)
            </button>
            <button class="panzoom-btn" onclick="panzoomAction('fit')" title="Fit to Screen">
                FIT
            </button>
            <button class="panzoom-btn" onclick="panzoomAction('reset')" title="Reset View">
                RST
            </button>
            
            <!-- Actions (Added via JS when complete) -->
            <button id="btnCopyConv" class="panzoom-btn" onclick="copyConversation()" style="display: none;" title="Copy Conversation">
                COPY CONV
            </button>
            <button id="btnExportPdf" class="panzoom-btn" onclick="exportToPdf()" style="display: none;" title="Export PDF">
                PDF
            </button>
            <button id="btnExportImg" class="panzoom-btn" onclick="exportToImage()" style="display: none;" title="Export Image">
                IMG
            </button>
            <button class="panzoom-btn" onclick="debugGenerateRandom()" title="Debug Gen" style="color: var(--max-color-accent);">
                TEST GEN
            </button>
            <button class="panzoom-btn" onclick="debugFit()" title="Debug Fit" style="color: var(--max-color-text-tertiary);">
                ?
            </button>
        </div>
      </div>
      
      <!-- Cell Detail Modal (Hidden) -->
      <div class="cell-detail-overlay" id="cellModal" onclick="closeCellModal(event)">
        <div class="cell-detail-modal">
          <h3 id="modalTitle" style="font-size: 18px; margin-bottom: 12px; color: var(--max-color-text-primary);">Action</h3>
          <div id="modalContext" style="color: var(--max-color-text-secondary); line-height: 1.6;">Context</div>
          <button onclick="closeCellModal(null)" style="margin-top: 20px; padding: 8px 16px; background: var(--max-color-surface-tertiary); border: 1px solid var(--max-color-border); color: var(--max-color-text-primary); border-radius: 6px; cursor: pointer;">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
  <script>
    // Global Error Reporting to Winston Backend
    (function() {
        const ORIGINAL_CONSOLE_ERROR = console.error;
        
        function sendLog(level, message, context = {}) {
            // Avoid infinite loops if the fetch itself fails
            try {
                fetch('/api/logs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        level,
                        message: typeof message === 'string' ? message : JSON.stringify(message),
                        context: {
                            url: window.location.href,
                            ...context
                        },
                        userAgent: navigator.userAgent,
                        timestamp: new Date().toISOString()
                    })
                }).catch(e => {
                    // Fallback to original console to ensure we see it locally at least
                    ORIGINAL_CONSOLE_ERROR.call(console, 'Failed to send log to backend:', e);
                });
            } catch (e) { /* ignore */ }
        }

        // 1. Capture Global Uncaught Errors
        window.onerror = function(msg, url, line, col, error) {
            sendLog('error', `Uncaught: ${msg}`, {
                file: url,
                line,
                line,
                col,
                stack: error ? error.stack : 'no-stack'
            });
            return false; // Let default handler run too
        };

        // 2. Capture Unhandled Promise Rejections
        window.onunhandledrejection = function(event) {
            sendLog('error', `Unhandled Rejection: ${event.reason}`, {
                reason: event.reason ? (event.reason.stack || event.reason) : 'unknown'
            });
        };

        // 3. Intercept console.error (Optional but useful for framework errors)
        console.error = function(...args) {
            // Call original first
            ORIGINAL_CONSOLE_ERROR.apply(console, args);
            
            // Format args
            const msg = args.map(a => 
                typeof a === 'object' ? (a.stack || JSON.stringify(a)) : String(a)
            ).join(' ');

            sendLog('error', msg, { type: 'console.error' });
        };
    })();
  </script>
  <script src="js/renderer.js?v=1010"></script>
  <script src="js/json-renderer.js"></script>
  <script>
    // ===========================================
    // State
    // ===========================================
    const state = {
      isStreaming: false,
      isConnected: false,
      conversationHistory: [],
      sessionConfig: {},
      currentView: 'map' // 'map' or 'json'
    };

    // Toggle View
    function toggleView() {
        state.currentView = state.currentView === 'map' ? 'json' : 'map';
        
        // Handle Panzoom Logic
        const viewport = document.getElementById('journeyDashboard');
        const controls = document.getElementById('panzoomControls');
        
        if (state.currentView === 'json') {
            if (window.panzoomInstance) {
                // Pause panzoom
                window.panzoomInstance.pause();
            }
            viewport.classList.add('json-view-mode');
            if (controls) controls.style.display = 'none';
        } else {
            if (window.panzoomInstance) {
                // Resume panzoom
                window.panzoomInstance.resume();
            }
            viewport.classList.remove('json-view-mode');
            if (controls) controls.style.display = 'flex';
        }

        if (currentJourney) {
            renderCurrentView();
        }
    }

    function renderCurrentView() {
        if (!currentJourney) return;
        
        if (state.currentView === 'map') {
            renderMap(currentJourney);
            // Re-init or fit if needed, but panzoom handles DOM changes gracefully mostly.
            // Maybe ensure size is updated if changed drastically
        } else {
            renderJson(currentJourney);
        }
    }

    // ===========================================
    // Panzoom Setup
    // ===========================================
    window.panzoomInstance = null;

    function initPanzoom() {
        const elem = document.getElementById('journeyDashboard'); // The element to zoom
        // Note: Panzoom should be applied to the inner content, but user interacts with viewport
        // Wait, I structured it as #panzoomViewport > #journeyDashboard
        // So Panzoom initializes on #journeyDashboard, and listens to events on #panzoomViewport (or itself if not set)
        
        // Actually, best practice:
        // elem is the canvas (child)
        // parent is the viewport
        
        const viewport = document.getElementById('panzoomViewport');
        if (!elem || !viewport) return;

        // Initialize Panzoom
        window.panzoomInstance = Panzoom(elem, {
            maxScale: 5,
            minScale: 0.1,
            canvas: true, // "Infinite canvas" mode
            contain: false, // Don't constrain to viewport
            cursor: 'grab',
            startScale: 1
        });

        // Enable Mouse Wheel
        viewport.addEventListener('wheel', window.panzoomInstance.zoomWithWheel);
        
        // Center initial content?
        // Let's do a fit on load if content exists
        setTimeout(() => {
             // panzoomInstance.zoom(1);
             // panzoomInstance.pan(0, 0);
        }, 100);
    }

    function panzoomAction(action) {
        if (!window.panzoomInstance) return;
        const pz = window.panzoomInstance;
        
        switch(action) {
            case 'zoomIn':
                pz.zoomIn();
                break;
            case 'zoomOut':
                pz.zoomOut();
                break;
            case 'reset':
                // Reset to show top-left of board
                // Board is at (80, 80) usually. 
                // We want that at (40, 40) on screen.
                // 40 = pan + 80 * 1 => pan = -40
                const dash = document.getElementById('journeyDashboard');
                const cont = document.querySelector('.journey-board-container');
                let resetX = -40; 
                let resetY = -40;
                
                if (dash && cont) {
                     // Calculate exact offset
                     // If board is at offsetLeft 80, and we want it at screen 40:
                     // 40 = pan + 80 => pan = -40.
                     // Generally: pan = desiredScreenPos - localPos
                     resetX = 40 - cont.offsetLeft;
                     resetY = 40 - cont.offsetTop;
                }
                
                pz.zoom(1);
                pz.pan(resetX, resetY);
                break;
            case 'fit':
                performFit();
                break;
        }
    }

    function performFit() {
        if (!window.panzoomInstance) return;
        const pz = window.panzoomInstance;
        const viewport = document.getElementById('panzoomViewport');
        const dashboard = document.getElementById('journeyDashboard');
        const container = document.querySelector('.journey-board-container');
        
        if (!viewport || !dashboard) return;
        
        // Ensure origin is top-left for our math to work
        dashboard.style.transformOrigin = '0 0';
        
        // 1. Get Dimensions
        const viewportRect = viewport.getBoundingClientRect();
        const viewportW = viewportRect.width;
        const viewportH = viewportRect.height;
        
        // 2. Determine Target Dimensions & Position (Unscaled)
        let targetX = 0;
        let targetY = 0;
        let targetW = dashboard.scrollWidth;
        let targetH = dashboard.scrollHeight;
        
        if (container) {
            targetX = container.offsetLeft;
            targetY = container.offsetTop;
            targetW = container.offsetWidth;
            targetH = container.offsetHeight;
        } else {
            // If no container (e.g. empty state), center the dashboard content roughly
            // Dashboard padding is 80px
            targetX = 0;
            targetY = 0;
        }

        if (targetW === 0 || targetH === 0 || viewportW === 0 || viewportH === 0) return;

        // 3. Calculate Scale
        const padding = 40; 
        const availableW = viewportW - (padding * 2);
        const availableH = viewportH - (padding * 2);
        
        const scaleX = availableW / targetW;
        const scaleY = availableH / targetH;
        
        // Clamp scale
        let newScale = Math.min(scaleX, scaleY);
        const minScale = 0.1;
        const maxScale = 5;
        newScale = Math.max(minScale, Math.min(maxScale, newScale));
        
        // 4. Calculate Pan
        // Center of container in dashboard coordinates
        const containerCenterX = targetX + (targetW / 2);
        const containerCenterY = targetY + (targetH / 2);
        
        // We want containerCenter to be at viewportCenter
        // P_x + C_x * S = V_x
        // P_x = V_x - C_x * S
        const panX = (viewportW / 2) - (containerCenterX * newScale);
        const panY = (viewportH / 2) - (containerCenterY * newScale);

        // 5. Execute
        pz.setOptions({ duration: 0, animate: false });
        
        // Force reset then apply to avoid accumulation errors
        // Note: Panzoom doesn't have a 'setTransform' method exposed directly on the instance usually, 
        // but zoom() and pan() work. 
        // We set scale first, then pan.
        pz.zoom(newScale);
        setTimeout(() => {
            pz.pan(panX, panY);
            
            // Re-enable animation
            setTimeout(() => {
                pz.setOptions({ duration: 200, animate: true });
            }, 50);
        }, 0);
        
        // DEBUG VISUALIZATION
        // Draw a red box around the target area to verify we have the right coordinates
        // remove old debug box
        const oldBox = document.getElementById('debug-fit-box');
        if (oldBox) oldBox.remove();
        
        /* Uncomment to see debug box
        const box = document.createElement('div');
        box.id = 'debug-fit-box';
        box.style.position = 'absolute';
        box.style.left = targetX + 'px';
        box.style.top = targetY + 'px';
        box.style.width = targetW + 'px';
        box.style.height = targetH + 'px';
        box.style.border = '4px solid red';
        box.style.pointerEvents = 'none';
        box.style.zIndex = '9999';
        dashboard.appendChild(box);
        */
        
        console.log("Fit Calc:", {
            vW: viewportW, vH: viewportH,
            tX: targetX, tY: targetY, tW: targetW, tH: targetH,
            scale: newScale,
            panX, panY
        });
    }

    let hasAutoFitComplete = false;

    // Listen for render events from renderer.js
    window.addEventListener('journeyRendered', (e) => {
        // Only auto-fit if we just completed
        if (currentJourney && (currentJourney.stage === 'COMPLETE' || currentJourney.status === 'READY_FOR_REVIEW')) {
             if (!hasAutoFitComplete) {
                 setTimeout(performFit, 100);
                 hasAutoFitComplete = true;
             }
        } else {
             // Reset logic if needed, but generally we don't go backwards from complete
        }
    });

    // Init on load
    document.addEventListener('DOMContentLoaded', initPanzoom);

    // Load History from LocalStorage
    function loadHistory() {
        const stored = localStorage.getItem('max_chat_history');
        if (stored) {
            try {
                const parsed = JSON.parse(stored);
                // Filter out system start messages just in case
                state.conversationHistory = parsed.filter(m => m.content !== "START_SESSION");
                
                // Re-render messages
                messagesArea.innerHTML = ''; // Clear existing (like loading msg)
                state.conversationHistory.forEach(msg => {
                    addMessage(msg.content, msg.role === 'assistant' || msg.role === 'model' ? 'ai' : 'user');
                });
                
                // Scroll to bottom
                setTimeout(() => messagesArea.scrollTop = messagesArea.scrollHeight, 100);
            } catch (e) {
                console.error("Failed to load history", e);
            }
        }
    }

    function saveHistory() {
        localStorage.setItem('max_chat_history', JSON.stringify(state.conversationHistory));
    }

    function clearHistory() {
        localStorage.removeItem('max_chat_history');
        state.conversationHistory = [];
        messagesArea.innerHTML = '';
    }

    // ===========================================
    // DOM Elements
    // ===========================================
    const messagesArea = document.getElementById('messagesArea');
    const chatInput = document.getElementById('chatInput');
    const sendButton = document.getElementById('sendButton');
    const inputWrapper = document.getElementById('inputWrapper');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const journeyDashboard = document.getElementById('journeyDashboard');
    let currentJourneyId = null;
    let currentJourney = null; // Store full object
    let lastJourneyVersion = 0;

    // ===========================================
    // Journey Visualization (Polling)
    // ===========================================
    async function pollJourneyState() {
      if (!currentJourneyId) return;

      // Skip polling for client-side debug journeys
      if (currentJourneyId.startsWith('debug-')) return;

      try {
        const response = await fetch(`/api/journey-state/${currentJourneyId}`);
        if (!response.ok) return;
        
        const journey = await response.json();
        
        if (journey) {
          lastJourneyVersion = journey.version;
          currentJourney = journey; // Update global state
          renderCurrentView();
        }
      } catch (e) {
        console.error("Polling error", e);
      }
    }

    // Poll every 2 seconds
    setInterval(pollJourneyState, 2000);

    // Initial Poll
    pollJourneyState();

    // Modal Logic
    // (Handled by renderer.js)


    // Capture Journey ID from AI responses (simple heuristic for prototype)
    // In a real app, the backend would send this in the metadata
    function checkForJourneyId(text) {
        // This is a hack for the prototype. Ideally the AI driver sends a structured event.
        // We'll rely on the fact that we can just query the *latest* journey for this demo
        // Or hardcode the ID if the AI mentions it. 
        // Better yet, let's just fetch the list and grab the most recent one for now.
        fetchLatestJourney();
    }

    async function fetchLatestJourney() {
        try {
             // We need a list endpoint, but Store.list exists in code. 
             // Let's assume we can hit GET /v1/journey-maps (if we implemented list)
             // Since we didn't expose list in API, we'll just check if we have one in local storage or 
             // wait for the AI to "create" one and we'll sniff it.
             
             // WORKAROUND: The driver (server.js) should return the journey ID.
             // For now, let's poll a "debug" endpoint or similar. 
             // Actually, let's just rely on the user to paste it or the AI to say it? No, that's bad UX.
             
             // Real Fix: I'll update the server.js to return the journeyId in the chat response metadata.
        } catch(e) {}
    }

    // ===========================================
    // Connection Check
    // ===========================================
    async function checkConnection() {
      try {
        const response = await fetch('/api/health');
        const data = await response.json();
        
        if (data.status === 'ok') {
          state.isConnected = true;
          statusDot.classList.add('connected');
          statusDot.classList.remove('error');
          statusText.textContent = `${data.model}`;
        }
      } catch (error) {
        state.isConnected = false;
        statusDot.classList.add('error');
        statusDot.classList.remove('connected');
        statusText.textContent = 'Not connected';
      }
    }

    // Check connection on load
    checkConnection();

    // ===========================================
    // URL Parameter Handling
    // ===========================================
    async function checkUrlParams() {
      const params = new URLSearchParams(window.location.search);
      
      // 1. Check for Config ID (Short Link)
      const configId = params.get('id') || params.get('config');
      let remoteConfig = {};

      if (configId) {
          try {
              const res = await fetch(`/api/admin/links/${configId}?_t=${Date.now()}`);
              if (res.ok) {
                  const linkData = await res.json();
                  remoteConfig = {
                      name: linkData.name,
                      role: linkData.role,
                      journeyName: linkData.journey,
                      welcomePrompt: linkData.welcomePrompt,
                      journeyPrompt: linkData.journeyPrompt,
                      knowledgeIds: linkData.knowledgeIds || (linkData.knowledgeId ? [linkData.knowledgeId] : null),
                      swimlanes: linkData.swimlanes
                  };
              }
          } catch (e) {
              console.error("Error fetching config:", e);
          }
      }

      // 2. Check URL first, then LocalStorage
      const journeyId = params.get('journeyId') || localStorage.getItem('max_journey_id');
      
      if (journeyId) {
          currentJourneyId = journeyId;
          localStorage.setItem('max_journey_id', journeyId);
          pollJourneyState();
      }

      // 3. Capture Context (Merge Remote + URL Params)
      // URL params take precedence over remote config
      
      // Parse URL swimlanes if present
      const urlSwimlanes = (() => {
        try {
            const s = params.get('swimlanes');
            return s ? JSON.parse(decodeURIComponent(s)) : null;
        } catch (e) { console.error('Failed to parse swimlanes', e); return null; }
      })();

      state.sessionConfig = {
          name: params.get('name') || remoteConfig.name,
          role: params.get('role') || remoteConfig.role,
          journeyName: params.get('journey') || remoteConfig.journeyName,
          welcomePrompt: params.get('welcome-prompt') || remoteConfig.welcomePrompt,
          journeyPrompt: params.get('journey-prompt') || remoteConfig.journeyPrompt,
          knowledgeIds: params.get('knowledge-ids') ? params.get('knowledge-ids').split(',') : remoteConfig.knowledgeIds,
          swimlanes: urlSwimlanes || remoteConfig.swimlanes,
          journeyId: journeyId
      };

      // Clean up undefined/null values
      Object.keys(state.sessionConfig).forEach(key => 
          state.sessionConfig[key] === null && delete state.sessionConfig[key]
      );

      // Log config for debugging
      console.log("[DEBUG] Session Config:", state.sessionConfig);
      // Send to backend logger to verify what user is sending
      if (typeof sendLog === 'function') {
          sendLog('info', 'Session Config Initialized', { 
              config: state.sessionConfig,
              hasWelcome: !!state.sessionConfig.welcomePrompt
          });
      }

      // Trigger AI Welcome if params exist (but only if we don't have a journeyId already loaded)
      // If we loaded a journeyId, the user likely wants to see the map first, 
      // OR continue the chat. 
      
      // Load History First
      loadHistory();

      // Decision: Only start conversation if history is empty AND no journey ID is present
      // If history exists, we resume. If journey ID exists, we resume context.
      
      // If we have URL params but NO journey ID, we must start a NEW conversation to apply those params.
      // The issue was that sometimes it would load history, see it's empty, but then not start.
      // OR it would see a journeyId in local storage (even if we wanted to reset).
      
      if (!journeyId && state.conversationHistory.length === 0) {
          // Add a small delay to ensure everything is initialized
          setTimeout(() => startConversation(), 500);
      }
    }
    
    function startConversation() {
        // Send a hidden "system start" signal
        // We don't add this to the UI history as a user message
        sendMessage(true); 
    }
    
    // Check for params after a brief delay to ensure DOM is ready
    setTimeout(checkUrlParams, 100);

    // ===========================================
    // Settings Handling
    // ===========================================
    async function fetchSettings() {
        try {
            const response = await fetch('/api/admin/settings');
            if (response.ok) {
                const settings = await response.json();
                if (settings.agentName) {
                    updateAgentName(settings.agentName);
                }
            }
        } catch (e) {
            console.error("Failed to fetch settings", e);
        }
    }

    function updateAgentName(name) {
        // Update Title
        document.title = name;
        
        // Update Meta Description
        document.querySelector('meta[name="description"]').setAttribute('content', `${name} - AI Assistant`);
        
        // Update Placeholder
        const chatInput = document.getElementById('chatInput');
        chatInput.placeholder = `Message ${name}...`;
    }

    // Fetch settings on load
    fetchSettings();

    // ===========================================
    // Input Handling
    // ===========================================
    function autoResize(el) {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 150) + 'px';
    }

    function toggleSendButton() {
      sendButton.disabled = !chatInput.value.trim() || state.isStreaming;
    }

    function handleKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function useSuggestion(text) {
      chatInput.value = text;
      autoResize(chatInput);
      toggleSendButton();
      chatInput.focus();
    }

    function setInputEnabled(enabled) {
      if (enabled) {
        inputWrapper.classList.remove('disabled');
        chatInput.disabled = false;
      } else {
        inputWrapper.classList.add('disabled');
        chatInput.disabled = true;
      }
      toggleSendButton();
    }

    // ===========================================
    // Typing Indicator
    // ===========================================
    function getDisplayName(type) {
        if (type === 'ai') {
            return (state.sessionConfig.agentName || 'MAX').toUpperCase();
        } else {
            // User
            let name = state.sessionConfig.name;
            if (!name && currentJourney && currentJourney.userName) {
                name = currentJourney.userName;
            }
            if (name) {
                return name.split(' ')[0].toUpperCase();
            }
            return 'YOU';
        }
    }

    function showTypingIndicator() {
      if (document.getElementById('typingIndicator')) return;

      const typingDiv = document.createElement('div');
      typingDiv.className = 'max-typing';
      typingDiv.id = 'typingIndicator';
      
      const name = getDisplayName('ai');

      typingDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-typing-dots">
          <div class="max-typing-dot"></div>
          <div class="max-typing-dot"></div>
          <div class="max-typing-dot"></div>
        </div>
      `;

      messagesArea.appendChild(typingDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    function removeTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      if (indicator) {
        indicator.remove();
      }
    }

    // ===========================================
    // Message Handling
    // ===========================================
    async function sendMessage(isSystemStart = false) {
      let text = '';
      
      if (isSystemStart) {
          // Special signal text that won't be shown to user but triggers the backend
          text = "START_SESSION"; 
      } else {
          text = chatInput.value.trim();
          if (!text || state.isStreaming) return;
      }

      // Add user message ONLY if it's not a system start
      if (!isSystemStart) {
          addMessage(text, 'user');
          state.conversationHistory.push({ role: 'user', content: text });
          saveHistory(); // Save
          
          // Clear input
          chatInput.value = '';
          chatInput.style.height = 'auto';
          toggleSendButton();
      }

      // Disable input while streaming
      state.isStreaming = true;
      setInputEnabled(false);

      // Show typing indicator immediately
      showTypingIndicator();

      // We will create the AI message bubble only when text actually arrives
      let aiMessageEl = null;
      let bubbleEl = null;

      try {
        // Start streaming request
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            history: state.conversationHistory.filter(h => h.content !== "START_SESSION"), // Don't send START_SESSION in history if it lingered
            config: state.sessionConfig, // Pass the context/config
            journeyId: currentJourneyId // Pass the ID so the model doesn't lose track
          })
        });

        if (!response.ok) {
          throw new Error('Failed to connect to server');
        }

        // Read SSE stream
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.error) {
                  throw new Error(data.error);
                }
                
                // If we get text and haven't created the bubble yet, do it now
                if (data.text) {
                  if (!aiMessageEl) {
                      removeTypingIndicator();
                      aiMessageEl = createStreamingMessage();
                      bubbleEl = aiMessageEl.querySelector('.max-message-bubble');
                  }
                  
                  fullResponse += data.text;
                  bubbleEl.innerHTML = formatMessage(fullResponse) + '<span class="streaming-cursor"></span>';
                  messagesArea.scrollTop = messagesArea.scrollHeight;
                }
                
                if (data.done) {
                  // If we finished but never got text (e.g. pure tool call?), ensure typing is gone
                  if (!aiMessageEl) removeTypingIndicator();
                  
                  if (aiMessageEl) {
                      // Remove cursor, finalize message
                      bubbleEl.innerHTML = formatMessage(fullResponse);
                      addMessageActions(aiMessageEl);
                      state.conversationHistory.push({ role: 'assistant', content: fullResponse });
                      saveHistory(); // Save
                  }
                  
                  if (data.journeyId) {
                      currentJourneyId = data.journeyId;
                      localStorage.setItem('max_journey_id', currentJourneyId);
                      // Trigger immediate poll
                      pollJourneyState();
                  }
                }
              } catch (e) {
                // Skip malformed JSON
                if (e.message !== 'Unexpected end of JSON input') {
                  throw e;
                }
              }
            }
          }
        }

      } catch (error) {
        console.error('Streaming error:', error);
        removeTypingIndicator();
        
        // Show error message
        if (!aiMessageEl) {
            aiMessageEl = createStreamingMessage();
            bubbleEl = aiMessageEl.querySelector('.max-message-bubble');
        }
        
        bubbleEl.innerHTML = `<p>Sorry, I encountered an error: ${escapeHtml(error.message)}</p>
                             <p>Please make sure the server is running and try again.</p>`;
        aiMessageEl.classList.add('max-message--error');
      }

      // Re-enable input
      state.isStreaming = false;
      setInputEnabled(true);
      chatInput.focus();
    }

    // Create message element for streaming
    function createStreamingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'max-message max-message--ai';
      
      const name = getDisplayName('ai');

      messageDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-message-content">
          <div class="max-message-bubble">
            <span class="streaming-cursor"></span>
          </div>
        </div>
      `;

      messagesArea.appendChild(messageDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
      
      return messageDiv;
    }

    // Add actions to message after streaming completes
    function addMessageActions(messageEl) {
      const contentEl = messageEl.querySelector('.max-message-content');
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'max-message-actions';
      actionsDiv.innerHTML = `
        <button class="max-message-action" onclick="copyMessage(this)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy
        </button>
      `;
      contentEl.appendChild(actionsDiv);
    }

    // Add static message (user messages)
    function addMessage(content, type) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `max-message max-message--${type}`;
      
      const name = getDisplayName(type);

      messageDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-message-content">
          <div class="max-message-bubble">${type === 'ai' ? formatMessage(content) : escapeHtml(content)}</div>
        </div>
      `;

      messagesArea.appendChild(messageDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    // ===========================================
    // Formatting Helpers
    // ===========================================
    function _legacy_escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function _legacy_formatMessage(text) {
      // Basic markdown-like formatting
      let formatted = escapeHtml(text);
      
      // Code blocks
      formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
      
      // Inline code
      formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
      
      // Headers (###)
      formatted = formatted.replace(/^###\s+(.*$)/gm, '<h3>$1</h3>');
      
      // Bold
      formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      
      // Italic
      formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      
      // Line breaks to paragraphs
      formatted = formatted
        .split(/\n\n+/)
        .map(para => para.trim())
        .filter(para => para)
        .map(para => {
          // Check if it's a list
          if (para.match(/^[-*â¢]\s/m)) {
            const items = para.split(/\n/).map(item => 
              `<li>${item.replace(/^[-*â¢]\s*/, '')}</li>`
            ).join('');
            return `<ul>${items}</ul>`;
          }
          // Check if it's a numbered list
          if (para.match(/^\d+\.\s/m)) {
            const items = para.split(/\n/).map(item => 
              `<li>${item.replace(/^\d+\.\s*/, '')}</li>`
            ).join('');
            return `<ol>${items}</ol>`;
          }
          return `<p>${para.replace(/\n/g, '<br>')}</p>`;
        })
        .join('');
      
      return formatted;
    }

    // Copy message content
    function copyMessage(btn) {
      const bubble = btn.closest('.max-message-content').querySelector('.max-message-bubble');
      navigator.clipboard.writeText(bubble.innerText);
      btn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"/>
        </svg>
        Copied!
      `;
      setTimeout(() => {
        btn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy
        `;
      }, 2000);
    }

    // Copy Full Conversation
    function copyConversation() {
        if (!state.conversationHistory || state.conversationHistory.length === 0) {
            alert("No conversation history to copy. (History is cleared on page reload)");
            return;
        }

        const text = state.conversationHistory
            .map(msg => `[${msg.role.toUpperCase()}]\n${msg.content}`)
            .join('\n\n-------------------\n\n');
        
        navigator.clipboard.writeText(text).then(() => {
            const btn = document.getElementById('copyConvBtn');
            const originalHtml = btn.innerHTML;
            
            btn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: #22c55e;">
                  <polyline points="20 6 9 17 4 12"/>
                </svg>
                Copied!
            `;
            
            setTimeout(() => {
                btn.innerHTML = originalHtml;
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy: ', err);
            alert('Failed to copy conversation to clipboard.');
        });
    }

    // Export to PDF
    function _legacy_exportToPdf(targetElementId = 'journeyDashboard') {
        const element = document.getElementById('journeyDashboard');
        const opt = {
          margin:       0.2, // Small margin
          filename:     `journey-map-${new Date().toISOString().split('T')[0]}.pdf`,
          image:        { type: 'jpeg', quality: 0.98 },
          html2canvas:  { scale: 2, useCORS: true },
          jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
        };

        html2pdf().set(opt).from(element).save();
    }

    // Export to Image (PNG)
    function exportToImage() {
        const element = document.querySelector('.journey-board-container');
        if (!element) return;

        // 1. Reset Transform to ensure full capture (on parent)
        const parent = document.getElementById('journeyDashboard');
        const originalTransform = parent.style.transform;
        parent.style.transform = 'none'; 
        
        // 2. Calculate Full Dimensions
        // We need the scroll dimensions to capture everything
        const width = element.scrollWidth;
        const height = element.scrollHeight;
        
        // 3. Configure html2pdf to use html2canvas with full dimensions
        // We set windowWidth/windowHeight to ensure it renders at full size
        const opt = {
            margin: 0,
            filename: `journey-map-${new Date().toISOString().split('T')[0]}.png`,
            image: { type: 'png', quality: 1.0 },
            html2canvas: { 
                scale: 2, // High res
                useCORS: true,
                backgroundColor: '#0a0c10', // Match background
                windowWidth: width,
                windowHeight: height,
                width: width,
                height: height,
                scrollX: 0,
                scrollY: 0,
                x: 0,
                y: 0
            },
            jsPDF: { unit: 'px', format: [width, height], orientation: 'landscape' } // Not used for img output but good practice
        };
        
        // 4. Capture
        html2pdf().set(opt).from(element).outputImg('img').then((img) => {
            // Create a link to download
            const link = document.createElement('a');
            link.href = img.src;
            link.download = `journey-map-${new Date().toISOString().split('T')[0]}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Restore transform
            parent.style.transform = originalTransform;
        }).catch(err => {
            console.error("Image export failed:", err);
            // Restore on error too
            parent.style.transform = originalTransform;
        });
    }

    // Reset / New Journey
    function startNewJourney() {
        // 1. Clear Local Storage History
        clearHistory(); 
        
        // 2. If we have a current journey ID, we should probably delete it from the backend 
        //    so it doesn't clutter the admin (optional, but requested "erase session")
        if (currentJourneyId) {
            // Fire and forget delete - we don't need to wait for it
            fetch(`/v1/journey-maps/${currentJourneyId}`, { method: 'DELETE' });
        }

        // 3. Clear Persistent ID
        localStorage.removeItem('max_journey_id'); 
        
        // 4. When resetting with URL params, we want to START FRESH, not resume.
        //    The issue is checkUrlParams might see a journeyId if we don't clear the URL.
        const url = new URL(window.location.href);
        url.searchParams.delete('journeyId');
        
        // 5. Hard Reload to ensure fresh state
        window.location.href = url.toString();
    }

    function hardReset() {
        if(confirm("Start over completely? This clears the current chat.")) {
            startNewJourney();
        }
    }

    function toggleMobileView() {
        document.body.classList.toggle('show-map');
        const btn = document.getElementById('mobileToggleBtn');
        if (document.body.classList.contains('show-map')) {
            btn.textContent = 'Chat';
        } else {
            btn.textContent = 'Map';
        }
    }

    // Fullscreen Toggle
    function toggleFullscreen() {
        const doc = window.document;
        const docEl = doc.documentElement;

        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            if (requestFullScreen) {
                requestFullScreen.call(docEl);
            } else {
                // Fallback for Safari iOS if API not supported on element
                alert("To use fullscreen on iOS, tap the 'Share' button and select 'Add to Home Screen'.");
            }
        } else {
            if (cancelFullScreen) {
                cancelFullScreen.call(doc);
            }
        }
    }

    // ===========================================
    // DEBUG: Fit Debugger
    // ===========================================
    function debugFit() {
        const viewport = document.getElementById('panzoomViewport');
        const dashboard = document.getElementById('journeyDashboard');
        const container = document.querySelector('.journey-board-container');
        const pz = window.panzoomInstance;
        
        console.group("Fit Debugger");
        console.log("Panzoom Instance:", pz);
        console.log("Viewport:", viewport ? viewport.getBoundingClientRect() : 'null');
        console.log("Dashboard:", dashboard ? {
            scrollW: dashboard.scrollWidth,
            scrollH: dashboard.scrollHeight,
            offsetW: dashboard.offsetWidth,
            offsetH: dashboard.offsetHeight,
            rect: dashboard.getBoundingClientRect()
        } : 'null');
        console.log("Container:", container ? {
            offsetLeft: container.offsetLeft,
            offsetTop: container.offsetTop,
            offsetW: container.offsetWidth,
            offsetH: container.offsetHeight,
            rect: container.getBoundingClientRect()
        } : 'null');
        
        if (pz) {
            console.log("Current Scale:", pz.getScale());
            console.log("Current Pan:", pz.getPan());
        }
        console.groupEnd();
        
        alert("Check console for debug info");
    }

    // ===========================================
    // DEBUG: Random Journey Generator
    // ===========================================
    function debugGenerateRandom() {
        const phasesPool = ["Discovery", "Research", "Evaluation", "Purchase", "Implementation", "Onboarding", "Usage", "Expansion", "Renewal", "Advocacy"];
        const swimlanesPool = ["Doing", "Thinking", "Feeling", "Touchpoints", "Pain Points", "Opportunities", "Data", "Systems"];
        
        // Random Count
        const phaseCount = Math.floor(Math.random() * 8) + 4; // 4 to 12 phases
        const swimlaneCount = Math.floor(Math.random() * 4) + 3; // 3 to 6 swimlanes
        
        // Select random subset
        const phases = phasesPool.sort(() => 0.5 - Math.random()).slice(0, phaseCount);
        const swimlanes = swimlanesPool.sort(() => 0.5 - Math.random()).slice(0, swimlaneCount);
        
        // Build Objects
        const phaseObjs = phases.map((p, i) => ({ phaseId: `p${i}`, name: p, summary: `Summary for ${p}. Lorem ipsum dolor sit amet.` }));
        const swimlaneObjs = swimlanes.map((s, i) => ({ swimlaneId: `s${i}`, name: s, summary: `Summary for ${s}. Consectetur adipiscing elit.` }));
        
        const cells = [];
        phaseObjs.forEach(p => {
            swimlaneObjs.forEach(s => {
                if (Math.random() > 0.2) { // 80% chance of cell
                    cells.push({
                        cellId: `${p.phaseId}-${s.swimlaneId}`,
                        phaseId: p.phaseId,
                        swimlaneId: s.swimlaneId,
                        headline: `Action in ${p.name}`,
                        description: `User is ${s.name.toLowerCase()} something related to ${p.name.toLowerCase()}. This is a generated description to test layout width and height.`
                    });
                }
            });
        });
        
        const journey = {
            id: 'debug-' + Date.now(),
            name: "Generated Test Journey",
            role: "Test Persona",
            userName: "Debug User",
            status: "READY_FOR_REVIEW",
            stage: "COMPLETE",
            description: "This is a randomly generated journey map to test the layout, fixed widths, board container, and dot grid background.",
            phases: phaseObjs,
            swimlanes: swimlaneObjs,
            cells: cells,
            mentalModels: "1. Model Alpha: Users think linear.\n2. Model Beta: Users jump around.\n3. Model Gamma: Price is key.",
            summaryOfFindings: "Overall, the journey is fragmented. We need better cohesion in the purchase phase.",
            quotes: ["This is the absolute best test quote I have ever seen."]
        };
        
        currentJourney = journey;
        currentJourneyId = journey.id;
        
        // Render
        renderMap(journey);
        
        // Ensure buttons show
        document.body.classList.add('journey-complete');
        
        // Fit
        setTimeout(() => {
            if(window.panzoomInstance) {
                performFit();
            }
        }, 100);
        
        console.log("Generated Journey:", journey);
    }
  </script>
</body>
</html>
