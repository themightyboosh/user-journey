<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="description" content="M.AX - AI Assistant">
  <meta name="theme-color" content="#0a0c10">
  <title>M.AX</title>
  <meta property="og:title" content="M.AX - Journey Mapping Assistant">
  <meta property="og:description" content="An intelligent AI assistant for creating detailed user journey maps.">
  <meta property="og:image" content="https://journey-mapper.monumental.ax/max_splash.png">
  <meta property="og:url" content="https://journey-mapper.monumental.ax/">
  <meta property="og:type" content="website">
  
  <!-- Fonts -->
  <style>
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Light.otf') format('opentype');
      font-weight: 300;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-LightItalic.otf') format('opentype');
      font-weight: 300;
      font-style: italic;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Regular.otf') format('opentype');
      font-weight: 400;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Italic.otf') format('opentype');
      font-weight: 400;
      font-style: italic;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-Bold.otf') format('opentype');
      font-weight: 700;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans';
      src: url('/fonts/Messina%20Sans/MessinaSans-BoldItalic.otf') format('opentype');
      font-weight: 700;
      font-style: italic;
    }

    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Light.otf') format('opentype');
      font-weight: 300;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Book.otf') format('opentype');
      font-weight: 350; /* Fallback for Book */
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Regular.otf') format('opentype');
      font-weight: 400;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-SemiBold.otf') format('opentype');
      font-weight: 600;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Bold.otf') format('opentype');
      font-weight: 700;
      font-style: normal;
    }
    @font-face {
      font-family: 'Messina Sans Mono';
      src: url('/fonts/Messina%20Sans%20Mono/MessinaSansMono-Black.otf') format('opentype');
      font-weight: 900;
      font-style: normal;
    }
  </style>
  
  <style>
    /* ========================================
       CSS VARIABLES
       ======================================== */
    :root {
      --max-color-background: #0a0c10;
      --max-color-surface-primary: #12141a;
      --max-color-surface-secondary: #1a1d24;
      --max-color-surface-tertiary: #22262f;
      --max-color-surface-hover: #2a2f3a;
      
      --max-color-text-primary: #f0f2f5;
      --max-color-text-secondary: #9ca3b4;
      --max-color-text-tertiary: #6b7280;
      --max-color-text-inverse: #0a0c10;
      
      --max-color-border: #2a2f3a;
      --max-color-border-subtle: #1e2229;
      
      --max-color-accent: #ed2224;
      --max-color-accent-hover: #ff4d4f;
      --max-color-accent-subtle: rgba(237, 34, 36, 0.15);
      
      --max-color-error: #ef4444;
      --max-color-error-subtle: rgba(239, 68, 68, 0.15);
      
      --max-color-ai-gradient-start: #ed2224;
      --max-color-ai-gradient-end: #c41e20;
      
      --max-font-family: 'Messina Sans', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --max-font-family-mono: 'Messina Sans Mono', 'SF Mono', Monaco, monospace;
      --max-radius-small: 8px;
      --max-radius-medium: 12px;
      --max-radius-large: 16px;
      --max-radius-xlarge: 20px;
      --max-radius-full: 9999px;
      
      --max-shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.3);
      --max-shadow-glow: 0 0 20px rgba(237, 34, 36, 0.3);
    }

    /* ========================================
       RESET & BASE
       ======================================== */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      height: 100dvh;
      overflow: hidden;
      /* iOS Safari specific fix to prevent bounce/overscroll */
      position: fixed;
      width: 100%;
    }

    body {
      font-family: var(--max-font-family);
      font-size: 15px;
      line-height: 1.5;
      color: var(--max-color-text-primary);
      background: var(--max-color-background);
      -webkit-font-smoothing: antialiased;
    }

    /* ========================================
       APP LAYOUT
       ======================================== */
    .max-app {
      display: flex;
      flex-direction: column;
      height: 100%;
      height: 100dvh;
      width: 100%;
      margin: 0 auto;
    }

    .max-main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* ========================================
       CHAT CANVAS (LEFT) - NOW RIGHT
       ======================================== */
    .max-chat-canvas {
      flex: 1 !important;
      width: auto !important;
      max-width: none !important;
      min-width: 0 !important;
      border-left: 1px solid var(--max-color-border-subtle);
      background: var(--max-color-surface-primary);
      display: flex;
      flex-direction: column;
      color: var(--max-color-text-tertiary);
      font-size: 14px;
      overflow: hidden;
    }

    .journey-dashboard {
      padding: 24px;
      overflow-y: auto;
      height: 100%;
      width: 100%;
    }

    .journey-header {
      margin-bottom: 24px;
      border-bottom: 1px solid var(--max-color-border-subtle);
      padding-bottom: 16px;
    }

    .journey-title {
      font-size: 24px;
      font-weight: 600;
      color: var(--max-color-accent);
      margin-bottom: 8px;
    }

    .journey-role {
      font-family: var(--max-font-family-mono);
      font-size: 14px;
      color: var(--max-color-text-primary);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .context-card {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      padding: 16px;
      margin-bottom: 24px;
    }

    .context-card h3 {
      font-family: var(--max-font-family-mono);
      font-size: 14px;
      font-weight: 600;
      color: var(--max-color-text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .context-content {
      font-size: 14px;
      line-height: 1.6;
      color: var(--max-color-text-primary);
      white-space: normal;
    }

    .context-content ul, .context-content ol {
      margin-left: 20px;
      margin-bottom: 12px;
    }
    .context-content li {
      margin-bottom: 4px;
    }
    .context-content p {
      margin-bottom: 12px;
    }
    .context-content h3 {
      font-size: 16px;
      font-weight: 600;
      color: var(--max-color-text-primary);
      margin-top: 16px;
      margin-bottom: 8px;
    }
    .context-content strong {
      color: var(--max-color-text-primary);
      font-weight: 600;
    }

    /* Living Table */
    .journey-table {
      display: grid;
      gap: 16px;
      /* Grid template columns set dynamically via JS */
    }

    .phase-header {
      font-weight: 600;
      color: var(--max-color-text-primary);
      text-align: center;
      padding: 8px;
      background: var(--max-color-surface-tertiary);
      border-radius: var(--max-radius-small);
      border: 1px solid var(--max-color-border);
    }

    .swimlane-header {
      font-weight: 600;
      color: var(--max-color-text-secondary);
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: center;
      padding-right: 12px;
      border-right: 2px solid var(--max-color-border);
      text-align: right;
    }

    .swimlane-name {
      color: var(--max-color-text-primary);
    }

    .swimlane-desc {
      font-family: var(--max-font-family-mono);
      font-size: 11px;
      color: var(--max-color-text-tertiary);
      margin-top: 4px;
      font-weight: 400;
      max-width: 100%;
      overflow: visible;
      text-overflow: clip;
      white-space: normal;
    }

    .journey-cell {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-small);
      padding: 12px;
      min-height: 100px;
      height: auto;
      transition: all 0.2s ease;
      cursor: pointer;
      position: relative;
    }

    .journey-cell:hover {
      border-color: var(--max-color-accent);
      transform: translateY(-2px);
      box-shadow: var(--max-shadow-soft);
    }

    .journey-cell.empty {
      background: transparent;
      border-style: dashed;
      opacity: 0.5;
      cursor: default;
    }

    .journey-cell.complete {
      border-left: 3px solid #22c55e;
    }

    .cell-action {
      font-weight: 500;
      color: var(--max-color-text-primary);
      margin-bottom: 6px;
      font-size: 13px;
    }

    .cell-context {
      font-family: var(--max-font-family-mono);
      font-size: 11px;
      color: var(--max-color-text-secondary);
      display: block;
      overflow: visible;
      white-space: normal;
    }

    /* ========================================
       MOBILE VIEW
       ======================================== */
    .journey-mobile-list {
      display: none;
      flex-direction: column;
      gap: 32px;
    }

    .mobile-phase-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .mobile-phase-header {
      font-size: 18px;
      font-weight: 700;
      color: var(--max-color-accent);
      padding-bottom: 8px;
      border-bottom: 1px solid var(--max-color-border);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .mobile-card {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      padding: 16px;
      cursor: pointer;
    }
    
    .mobile-card-label {
        font-family: var(--max-font-family-mono);
        font-size: 11px;
        color: var(--max-color-text-tertiary);
        margin-bottom: 8px;
        text-transform: uppercase;
        font-weight: 700;
    }

    /* Mobile Responsive Logic */
    @media (max-width: 768px) {
        .journey-table { display: none !important; }
        .journey-mobile-list { display: flex !important; }
        
        /* Hide logo in journey title on mobile */
        .journey-title svg { display: none !important; }
        
        /* Adjust layout */
        .max-chat-canvas {
            width: 100% !important;
            min-width: 0 !important;
        }
        
        /* Stack buttons on mobile */
        .action-area {
            flex-direction: column;
            align-items: stretch;
        }
        .action-area button {
            width: 100% !important;
        }
    }

    /* Modal / Detail View */
    .cell-detail-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 10;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .cell-detail-modal {
      background: var(--max-color-surface-primary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      padding: 24px;
      width: 80%;
      max-width: 500px;
      box-shadow: var(--max-shadow-glow);
    }

    /* ========================================
       HEADER
       ======================================== */
    .max-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid var(--max-color-border-subtle);
      flex-shrink: 0;
    }

    .max-logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .max-logo-icon {
      width: 36px;
      height: 36px;
      background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end));
      border-radius: var(--max-radius-small);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
    }

    .max-logo-icon svg {
      width: 20px;
      height: 20px;
    }

    .max-logo-text {
      font-family: var(--max-font-family);
      font-size: 20px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .max-logo-text span {
      color: var(--max-color-accent);
    }

    .max-status {
      font-family: var(--max-font-family-mono);
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--max-color-text-tertiary);
    }

    .max-status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--max-color-text-tertiary);
    }

    .max-status-dot.connected {
      background: #22c55e;
    }

    .max-status-dot.error {
      background: var(--max-color-error);
    }

    /* ========================================
       CHAT CONTAINER (RIGHT)
       ======================================== */
    .max-chat-container {
      flex: 0 0 480px !important;
      width: 480px !important;
      max-width: 480px !important;
      min-width: 480px !important;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--max-color-background);
    }

    /* ========================================
       MESSAGES AREA
       ======================================== */
    .max-messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .max-messages::-webkit-scrollbar {
      width: 6px;
    }

    .max-messages::-webkit-scrollbar-track {
      background: transparent;
    }

    .max-messages::-webkit-scrollbar-thumb {
      background: var(--max-color-border);
      border-radius: var(--max-radius-full);
    }

    /* Welcome State */
    .max-welcome {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 20px;
    }

    .max-welcome-icon {
      width: 72px;
      height: 72px;
      background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end));
      border-radius: var(--max-radius-large);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
      box-shadow: var(--max-shadow-glow);
    }

    .max-welcome-icon svg {
      width: 36px;
      height: 36px;
      color: white;
    }

    .max-welcome h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 12px;
      letter-spacing: -0.02em;
    }

    .max-welcome p {
      font-size: 16px;
      color: var(--max-color-text-secondary);
      max-width: 400px;
      margin-bottom: 32px;
    }

    .max-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .max-suggestion {
      padding: 10px 16px;
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-full);
      color: var(--max-color-text-secondary);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .max-suggestion:hover {
      background: var(--max-color-surface-hover);
      color: var(--max-color-text-primary);
      border-color: var(--max-color-accent);
    }

    /* ========================================
       MESSAGE BUBBLES
       ======================================== */
    .max-message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-width: 100%;
      animation: messageIn 0.3s ease;
    }

    @keyframes messageIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .max-message--user {
      align-items: flex-end;
    }

    .max-message-header {
      font-family: var(--max-font-family-mono);
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      line-height: 1;
      width: fit-content;
      letter-spacing: 0.05em;
    }

    .max-message--ai .max-message-header {
      background: var(--max-color-accent);
    }

    .max-message--user .max-message-header {
      background: var(--max-color-surface-tertiary);
      color: var(--max-color-text-secondary);
    }

    /* AI Bubble - Gray */
    .max-message--ai .max-message-bubble {
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border-subtle);
      border-radius: var(--max-radius-medium);
      border-top-left-radius: 4px; /* Align with header */
    }

    /* User Bubble - Red */
    .max-message--user .max-message-bubble {
      background: var(--max-color-accent);
      color: white;
      border: 1px solid var(--max-color-accent); /* Match border to bg */
      border-radius: var(--max-radius-medium);
      border-top-right-radius: 4px;
      margin-left: auto;
    }

    .max-message-content {
      flex: 1;
      min-width: 0;
      max-width: 100%;
    }

    .max-message-bubble {
      padding: 14px 18px;
      line-height: 1.6;
    }

    .max-message--error .max-message-bubble {
      background: var(--max-color-error-subtle);
      border-color: var(--max-color-error);
      color: var(--max-color-error);
    }

    .max-message-bubble h3 {
      font-size: 16px;
      font-weight: 600;
      margin-top: 12px;
      margin-bottom: 8px;
      color: inherit;
    }

    .max-message-bubble p {
      margin-bottom: 12px;
    }

    .max-message-bubble p:last-child {
      margin-bottom: 0;
    }

    .max-message-bubble ul, .max-message-bubble ol {
      margin: 12px 0;
      padding-left: 20px;
    }

    .max-message-bubble li {
      margin-bottom: 6px;
    }

    .max-message-bubble code {
      background: var(--max-color-surface-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 13px;
      font-family: var(--max-font-family-mono);
    }

    .max-message-bubble pre {
      background: var(--max-color-surface-primary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-small);
      padding: 12px;
      margin: 12px 0;
      overflow-x: auto;
    }

    .max-message-bubble pre code {
      background: transparent;
      padding: 0;
    }

    /* Streaming cursor */
    .max-message-bubble .streaming-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: var(--max-color-accent);
      margin-left: 2px;
      animation: cursorBlink 1s step-end infinite;
      vertical-align: text-bottom;
    }

    @keyframes cursorBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .max-message-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .max-message:hover .max-message-actions {
      opacity: 1;
    }

    .max-message-action {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 6px 10px;
      background: transparent;
      border: none;
      border-radius: var(--max-radius-small);
      color: var(--max-color-text-tertiary);
      font-size: 11px;
      font-family: var(--max-font-family-mono);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .max-message-action:hover {
      background: var(--max-color-surface-tertiary);
      color: var(--max-color-text-secondary);
    }

    .max-message-action svg {
      width: 14px;
      height: 14px;
    }

    /* ========================================
       TYPING INDICATOR
       ======================================== */
    .max-typing {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-start;
      margin-bottom: 24px;
    }

    .max-typing-dots {
      display: flex;
      gap: 4px;
      padding: 16px 20px;
      background: var(--max-color-surface-secondary);
      border-radius: var(--max-radius-large);
      border-top-left-radius: 4px;
      border: 1px solid var(--max-color-border-subtle);
    }

    .max-typing-dot {
      width: 8px;
      height: 8px;
      background: var(--max-color-text-tertiary);
      border-radius: 50%;
      animation: typingBounce 1.4s ease-in-out infinite;
    }

    .max-typing-dot:nth-child(2) { animation-delay: 0.15s; }
    .max-typing-dot:nth-child(3) { animation-delay: 0.3s; }

    @keyframes typingBounce {
      0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
      }
      30% {
        transform: translateY(-8px);
        opacity: 1;
      }
    }

    /* ========================================
       INPUT AREA
       ======================================== */
    .max-input-area {
      padding: 16px 24px 24px;
      border-top: 1px solid var(--max-color-border-subtle);
    }

    .max-input-wrapper {
      display: flex;
      align-items: flex-end;
      gap: 12px;
      background: var(--max-color-surface-secondary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-xlarge);
      padding: 8px 8px 8px 20px;
      transition: all 0.2s ease;
    }

    .max-input-wrapper:focus-within {
      border-color: var(--max-color-accent);
      box-shadow: var(--max-shadow-glow);
    }

    .max-input-wrapper.disabled {
      opacity: 0.6;
      pointer-events: none;
    }

    .max-input {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: 15px;
      color: var(--max-color-text-primary);
      resize: none;
      max-height: 150px;
      min-height: 24px;
      line-height: 1.5;
      padding: 8px 0;
    }

    .max-input::placeholder {
      color: var(--max-color-text-tertiary);
    }

    .max-send-button {
      width: 44px;
      height: 44px;
      background: var(--max-color-accent);
      border: none;
      border-radius: var(--max-radius-medium);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .max-send-button:hover:not(:disabled) {
      background: var(--max-color-accent-hover);
      transform: scale(1.05);
    }

    .max-send-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .max-send-button svg {
      width: 20px;
      height: 20px;
    }

    .max-input-hint {
      font-family: var(--max-font-family-mono);
      text-align: center;
      font-size: 11px;
      color: var(--max-color-text-tertiary);
      margin-top: 10px;
    }

    .max-input-hint kbd {
      background: var(--max-color-surface-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: inherit;
    }

    /* ========================================
       COMPLETION STATE
       ======================================== */
    body.journey-complete .max-chat-container {
      display: none !important;
    }
    
    body.journey-complete .max-chat-canvas {
      flex: 0 0 100% !important;
      width: 100% !important;
      max-width: 100% !important;
      border-right: none;
    }

    /* ========================================
       RESPONSIVE
       ======================================== */
    .mobile-toggle-btn {
      display: none;
      padding: 8px 16px;
      background: var(--max-color-surface-tertiary);
      border: 1px solid var(--max-color-border);
      border-radius: var(--max-radius-medium);
      color: var(--max-color-text-primary);
      font-size: 13px;
      font-family: var(--max-font-family-mono);
      font-weight: 500;
      cursor: pointer;
      margin-right: 12px;
    }

    @media (max-width: 768px) {
      .max-main-content {
        flex-direction: column; /* Normal column, we toggle visibility */
      }
      .max-chat-canvas, .max-chat-container {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 100% !important;
        flex: 1 !important;
        height: 100%;
        border: none;
      }
      
      /* Toggle Logic */
      body:not(.show-map) .max-chat-canvas { display: none !important; }
      body.show-map .max-chat-container { display: none !important; }
      
      .mobile-toggle-btn { display: block; }
      
      /* Header adjustments */
      .max-header { padding: 12px 16px; }
      .max-logo-text { display: none; } /* Save space */
      
      /* Hide Model Name on Mobile */
      .desktop-only { display: none !important; }
    }

    /* Reset Button Style */
    .reset-btn {
        background: none;
        border: 1px solid var(--max-color-border);
        border-radius: 4px;
        color: var(--max-color-text-tertiary);
        cursor: pointer;
        padding: 4px 8px;
        margin-left: 8px;
        font-family: var(--max-font-family-mono);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: all 0.15s ease;
    }
    .reset-btn:hover {
        background: var(--max-color-surface-tertiary);
        color: var(--max-color-text-primary);
        border-color: var(--max-color-text-secondary);
    }

    /* ========================================
       PDF EXPORT STYLES
       ======================================== */
    .pdf-export-mode {
      --max-color-background: #ffffff !important;
      --max-color-surface-primary: #ffffff !important;
      --max-color-surface-secondary: #ffffff !important;
      --max-color-surface-tertiary: #f3f4f6 !important;
      
      --max-color-text-primary: #111827 !important;
      --max-color-text-secondary: #4b5563 !important;
      --max-color-text-tertiary: #6b7280 !important;
      
      --max-color-border: #e5e7eb !important;
      --max-color-border-subtle: #f3f4f6 !important;
      
      color: #000000 !important;
      background: #ffffff !important;
    }

    /* Force background colors for PDF generation */
    .pdf-export-mode .journey-cell {
        background: #ffffff !important;
        border: 1px solid #e5e7eb !important;
        color: #000 !important;
        break-inside: avoid;
        page-break-inside: avoid;
    }

    /* Page Break Helper */
    .html2pdf__page-break {
        page-break-before: always;
    }
  </style>
</head>
<body>
  <div class="max-app">
    
    <!-- Header -->
    <header class="max-header">
      <div class="max-logo" onclick="toggleView()" style="cursor: pointer;" title="Toggle View (Map/JSON)">
          <img src="max_header.svg" alt="M.AX" style="height: 32px; width: auto;">
      </div>
      <div class="max-status" id="connectionStatus">
        <button id="mobileToggleBtn" class="mobile-toggle-btn" onclick="toggleMobileView()">Map</button>
        <span class="max-status-dot" id="statusDot"></span>
        <span id="statusText" class="desktop-only">Connecting...</span>
        <button onclick="hardReset()" title="Reset Session" class="reset-btn">
            RESET
        </button>
      </div>
    </header>

    <div class="max-main-content">
      <!-- Chat Container (Left) -->
      <div class="max-chat-container">
        
        <!-- Messages Area -->
        <div class="max-messages" id="messagesArea">
        </div>

      <!-- Input Area -->
      <div class="max-input-area">
        <div class="max-input-wrapper" id="inputWrapper">
          <textarea 
            class="max-input" 
            id="chatInput"
            placeholder="Message M.AX..."
            rows="1"
            onkeydown="handleKeyDown(event)"
            oninput="autoResize(this); toggleSendButton()"
          ></textarea>
          <button class="max-send-button" id="sendButton" onclick="sendMessage()" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 2L11 13"/>
              <path d="M22 2L15 22L11 13L2 9L22 2Z"/>
            </svg>
          </button>
        </div>
        <div class="max-input-hint" style="display: none;">
          <kbd>Enter</kbd> to send Â· <kbd>Shift + Enter</kbd> for new line
        </div>
      </div>
    </div>

        <!-- Chat Canvas (Right) -->
      <div class="max-chat-canvas" id="chatCanvas">
        <div class="journey-dashboard" id="journeyDashboard">
           <div style="height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; opacity: 0.5; gap: 24px;">
              <div style="width: 300px; height: 300px; background: linear-gradient(135deg, var(--max-color-ai-gradient-start), var(--max-color-ai-gradient-end)); border-radius: 72px; display: flex; align-items: center; justify-content: center; box-shadow: var(--max-shadow-glow);">
                  <svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128.5 42.6" style="width: 180px; height: auto;">
                      <path d="M5.9,42.6c-1.5,0-2.7-.3-3.6-.9-.9-.6-1.5-1.4-1.8-2.3s-.5-1.9-.5-3V9.1C0,6.2.7,3.9,2.2,2.5,3.7,1,5.9.3,9,.3s3.7.2,4.8.7c1.2.5,2.1,1.3,2.8,2.3.7,1.1,1.2,2.4,1.7,4.1l.3,1.2c.7,2.2,1.2,4,1.6,5.6.4,1.6.7,3,1,4.4.3,1.3.5,2.6.6,3.9.2,1.3.3,2.6.4,4.1.1-1.5.3-2.9.4-4.1s.4-2.6.6-3.9c.3-1.3.6-2.8,1-4.4.4-1.6,1-3.5,1.6-5.6l.3-1.2c.5-1.7,1.1-3,1.8-4.1.7-1.1,1.6-1.8,2.8-2.3,1.2-.5,2.8-.7,4.8-.7,3.1,0,5.4.7,6.8,2.2,1.4,1.5,2.2,3.7,2.2,6.6v27.2c0,1-.2,2-.5,3s-.9,1.7-1.8,2.3-2.1.9-3.6.9-2.7-.3-3.6-.9c-.9-.6-1.5-1.4-1.8-2.3s-.5-1.9-.5-3v-4.9c0-2.7.2-5.7.4-9,.2-3.3.4-7.2.5-11.5l-5.2,19.4c-.4,1.3-.8,2.4-1.3,3.2-.4.8-1,1.4-1.8,1.8-.4-.8-.9-1.9-1.3-3.2l-5.2-19.4c.1,4.3.3,8.2.5,11.5s.3,6.4.4,9v4.9c0,1-.1,2-.4,3s-.9,1.7-1.8,2.3c-.9.6-2.1.9-3.6.9h0l.2.1Z" style="fill: #ffffff;"/>
                      <path d="M54.1,42.6c-.9,0-1.8-.2-2.8-.7s-1.7-1.2-2.4-2.1c-.6-.9-1-2-1-3.4s0-1.3.2-2.1c.1-.8.4-1.6.8-2.4l9.6-22.9c.6-1.5,1.2-2.9,1.7-4s1.1-2,1.7-2.8c.6-.7,1.4-1.3,2.4-1.6,1-.4,2.2-.5,3.8-.5s2.8.2,3.8.5c1,.4,1.8.9,2.4,1.6s1.2,1.7,1.7,2.8,1.1,2.4,1.7,4l9.6,22.9c.4.8.6,1.6.8,2.4.1.8.2,1.5.2,2.1,0,1.3-.3,2.5-1,3.4-.6.9-1.4,1.6-2.3,2.1s-1.9.7-2.8.7c-1.6,0-2.8-.3-3.7-1-.9-.7-1.6-1.6-2.1-2.7-.5-1.1-1-2.3-1.4-3.5l-1.3-4.2v-3.3c.1,0-3.8-10.1-3.8-10.1-.3-.8-.6-1.8-1-3s-.6-2.3-.9-3.2c-.2.9-.5,1.9-.9,3.2-.4,1.2-.7,2.2-1,3l-3.9,10.1v3.3c.1,0-1.2,4.2-1.2,4.2-.4,1.2-.8,2.4-1.3,3.5s-1.2,2-2.1,2.7-2.1,1-3.7,1h.2ZM59.2,33.1v-7.6h17.7v7.6h-17.7Z" style="fill: #ffffff;"/>
                      <path d="M97.8,42.6c-1.1,0-2.2-.3-3.2-.8s-1.9-1.3-2.5-2.3c-.7-1-1-2.2-1-3.7,0-1.9.5-3.5,1.6-4.7,1-1.2,2.4-2.5,4.1-3.9,1.2-.9,2.4-1.7,3.5-2.6,1.2-.9,2.3-1.8,3.5-2.7-.8-.7-1.9-1.6-3.2-2.7s-2.6-2.2-3.9-3.3c-1.7-1.4-3.1-2.8-4.1-4.1s-1.5-2.9-1.5-5c0-1.4.4-2.6,1-3.7.7-1,1.5-1.8,2.5-2.3,1-.5,2.1-.8,3.2-.8s2.5.3,3.4.8c.9.6,1.7,1.3,2.4,2.2s1.4,2,2,3.2c1,1.9,1.8,3.7,2.5,5.3s1.3,2.8,1.6,3.7c.3-.9.9-2.1,1.6-3.7.7-1.6,1.6-3.4,2.5-5.3.6-1.2,1.3-2.3,2-3.2.7-.9,1.5-1.7,2.4-2.2,1.1-.5,2.2-.8,3.5-.8s2.2.3,3.3.8c1,.5,1.9,1.3,2.5,2.4.7,1,1,2.2,1,3.7,0,2.1-.5,3.7-1.5,5-1,1.3-2.4,2.7-4.1,4.1-1.2,1-2.3,2-3.5,3s-2.3,2-3.5,2.9c.8.6,1.9,1.4,3.1,2.3,1.2,1,2.5,2,3.7,3,1.7,1.4,3.1,2.7,4.1,3.9,1,1.2,1.6,2.8,1.6,4.7s-.3,2.6-1,3.7c-.7,1-1.5,1.8-2.5,2.3s-2.1.8-3.3.8c-1.3,0-2.5-.3-3.4-.9-.9-.5-1.7-1.3-2.4-2.2-.7-1-1.4-2-2-3.2-.9-1.7-1.7-3.3-2.4-4.7-.8-1.4-1.3-2.7-1.7-3.7-.3,1-.9,2.3-1.7,3.7-.8,1.5-1.6,3-2.4,4.6-1,1.8-2,3.3-3.1,4.5s-2.7,1.8-4.7,1.8h0v.1Z" style="fill: #ffffff;"/>
                  </svg>
              </div>
              <h1 style="font-family: var(--max-font-family-mono); font-weight: 700; letter-spacing: 0.1em; color: var(--max-color-text-tertiary); margin-top: 16px; font-size: 14px;">JOURNEY MAP</h1>
           </div>
        </div>
      </div>
      
      <!-- Cell Detail Modal (Hidden) -->
      <div class="cell-detail-overlay" id="cellModal" onclick="closeCellModal(event)">
        <div class="cell-detail-modal">
          <h3 id="modalTitle" style="font-size: 18px; margin-bottom: 12px; color: var(--max-color-text-primary);">Action</h3>
          <div id="modalContext" style="color: var(--max-color-text-secondary); line-height: 1.6;">Context</div>
          <button onclick="closeCellModal(null)" style="margin-top: 20px; padding: 8px 16px; background: var(--max-color-surface-tertiary); border: 1px solid var(--max-color-border); color: var(--max-color-text-primary); border-radius: 6px; cursor: pointer;">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script>
    // Global Error Reporting to Winston Backend
    (function() {
        const ORIGINAL_CONSOLE_ERROR = console.error;
        
        function sendLog(level, message, context = {}) {
            // Avoid infinite loops if the fetch itself fails
            try {
                fetch('/api/logs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        level,
                        message: typeof message === 'string' ? message : JSON.stringify(message),
                        context: {
                            url: window.location.href,
                            ...context
                        },
                        userAgent: navigator.userAgent,
                        timestamp: new Date().toISOString()
                    })
                }).catch(e => {
                    // Fallback to original console to ensure we see it locally at least
                    ORIGINAL_CONSOLE_ERROR.call(console, 'Failed to send log to backend:', e);
                });
            } catch (e) { /* ignore */ }
        }

        // 1. Capture Global Uncaught Errors
        window.onerror = function(msg, url, line, col, error) {
            sendLog('error', `Uncaught: ${msg}`, {
                file: url,
                line,
                col,
                stack: error ? error.stack : 'no-stack'
            });
            return false; // Let default handler run too
        };

        // 2. Capture Unhandled Promise Rejections
        window.onunhandledrejection = function(event) {
            sendLog('error', `Unhandled Rejection: ${event.reason}`, {
                reason: event.reason ? (event.reason.stack || event.reason) : 'unknown'
            });
        };

        // 3. Intercept console.error (Optional but useful for framework errors)
        console.error = function(...args) {
            // Call original first
            ORIGINAL_CONSOLE_ERROR.apply(console, args);
            
            // Format args
            const msg = args.map(a => 
                typeof a === 'object' ? (a.stack || JSON.stringify(a)) : String(a)
            ).join(' ');

            sendLog('error', msg, { type: 'console.error' });
        };
    })();
  </script>
  <script src="js/renderer.js"></script>
  <script src="js/json-renderer.js"></script>
  <script>
    // ===========================================
    // State
    // ===========================================
    const state = {
      isStreaming: false,
      isConnected: false,
      conversationHistory: [],
      sessionConfig: {},
      currentView: 'map' // 'map' or 'json'
    };

    // Toggle View
    function toggleView() {
        state.currentView = state.currentView === 'map' ? 'json' : 'map';
        if (currentJourney) {
            renderCurrentView();
        }
    }

    function renderCurrentView() {
        if (!currentJourney) return;
        
        if (state.currentView === 'map') {
            renderMap(currentJourney);
        } else {
            renderJson(currentJourney);
        }
    }

    // Load History from LocalStorage
    function loadHistory() {
        const stored = localStorage.getItem('max_chat_history');
        if (stored) {
            try {
                const parsed = JSON.parse(stored);
                // Filter out system start messages just in case
                state.conversationHistory = parsed.filter(m => m.content !== "START_SESSION");
                
                // Re-render messages
                messagesArea.innerHTML = ''; // Clear existing (like loading msg)
                state.conversationHistory.forEach(msg => {
                    addMessage(msg.content, msg.role === 'assistant' || msg.role === 'model' ? 'ai' : 'user');
                });
                
                // Scroll to bottom
                setTimeout(() => messagesArea.scrollTop = messagesArea.scrollHeight, 100);
            } catch (e) {
                console.error("Failed to load history", e);
            }
        }
    }

    function saveHistory() {
        localStorage.setItem('max_chat_history', JSON.stringify(state.conversationHistory));
    }

    function clearHistory() {
        localStorage.removeItem('max_chat_history');
        state.conversationHistory = [];
        messagesArea.innerHTML = '';
    }

    // ===========================================
    // DOM Elements
    // ===========================================
    const messagesArea = document.getElementById('messagesArea');
    const chatInput = document.getElementById('chatInput');
    const sendButton = document.getElementById('sendButton');
    const inputWrapper = document.getElementById('inputWrapper');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const journeyDashboard = document.getElementById('journeyDashboard');
    let currentJourneyId = null;
    let currentJourney = null; // Store full object
    let lastJourneyVersion = 0;

    // ===========================================
    // Journey Visualization (Polling)
    // ===========================================
    async function pollJourneyState() {
      if (!currentJourneyId) return;

      try {
        const response = await fetch(`/api/journey-state/${currentJourneyId}`);
        if (!response.ok) return;
        
        const journey = await response.json();
        
        if (journey) {
          lastJourneyVersion = journey.version;
          currentJourney = journey; // Update global state
          renderCurrentView();
        }
      } catch (e) {
        console.error("Polling error", e);
      }
    }

    // Poll every 2 seconds
    setInterval(pollJourneyState, 2000);

    // Initial Poll
    pollJourneyState();

    // Modal Logic
    // (Handled by renderer.js)


    // Capture Journey ID from AI responses (simple heuristic for prototype)
    // In a real app, the backend would send this in the metadata
    function checkForJourneyId(text) {
        // This is a hack for the prototype. Ideally the AI driver sends a structured event.
        // We'll rely on the fact that we can just query the *latest* journey for this demo
        // Or hardcode the ID if the AI mentions it. 
        // Better yet, let's just fetch the list and grab the most recent one for now.
        fetchLatestJourney();
    }

    async function fetchLatestJourney() {
        try {
             // We need a list endpoint, but Store.list exists in code. 
             // Let's assume we can hit GET /v1/journey-maps (if we implemented list)
             // Since we didn't expose list in API, we'll just check if we have one in local storage or 
             // wait for the AI to "create" one and we'll sniff it.
             
             // WORKAROUND: The driver (server.js) should return the journey ID.
             // For now, let's poll a "debug" endpoint or similar. 
             // Actually, let's just rely on the user to paste it or the AI to say it? No, that's bad UX.
             
             // Real Fix: I'll update the server.js to return the journeyId in the chat response metadata.
        } catch(e) {}
    }

    // ===========================================
    // Connection Check
    // ===========================================
    async function checkConnection() {
      try {
        const response = await fetch('/api/health');
        const data = await response.json();
        
        if (data.status === 'ok') {
          state.isConnected = true;
          statusDot.classList.add('connected');
          statusDot.classList.remove('error');
          statusText.textContent = `${data.model}`;
        }
      } catch (error) {
        state.isConnected = false;
        statusDot.classList.add('error');
        statusDot.classList.remove('connected');
        statusText.textContent = 'Not connected';
      }
    }

    // Check connection on load
    checkConnection();

    // ===========================================
    // URL Parameter Handling
    // ===========================================
    async function checkUrlParams() {
      const params = new URLSearchParams(window.location.search);
      
      // 1. Check for Config ID (Short Link)
      const configId = params.get('id') || params.get('config');
      let remoteConfig = {};

      if (configId) {
          try {
              const res = await fetch(`/api/admin/links/${configId}`);
              if (res.ok) {
                  const linkData = await res.json();
                  remoteConfig = {
                      name: linkData.name,
                      role: linkData.role,
                      journeyName: linkData.journey,
                      welcomePrompt: linkData.welcomePrompt,
                      journeyPrompt: linkData.journeyPrompt,
                      knowledgeIds: linkData.knowledgeIds || (linkData.knowledgeId ? [linkData.knowledgeId] : null),
                      swimlanes: linkData.swimlanes
                  };
              }
          } catch (e) {
              console.error("Error fetching config:", e);
          }
      }

      // 2. Check URL first, then LocalStorage
      const journeyId = params.get('journeyId') || localStorage.getItem('max_journey_id');
      
      if (journeyId) {
          currentJourneyId = journeyId;
          localStorage.setItem('max_journey_id', journeyId);
          pollJourneyState();
      }

      // 3. Capture Context (Merge Remote + URL Params)
      // URL params take precedence over remote config
      
      // Parse URL swimlanes if present
      const urlSwimlanes = (() => {
        try {
            const s = params.get('swimlanes');
            return s ? JSON.parse(decodeURIComponent(s)) : null;
        } catch (e) { console.error('Failed to parse swimlanes', e); return null; }
      })();

      state.sessionConfig = {
          name: params.get('name') || remoteConfig.name,
          role: params.get('role') || remoteConfig.role,
          journeyName: params.get('journey') || remoteConfig.journeyName,
          welcomePrompt: params.get('welcome-prompt') || remoteConfig.welcomePrompt,
          journeyPrompt: params.get('journey-prompt') || remoteConfig.journeyPrompt,
          knowledgeIds: params.get('knowledge-ids') ? params.get('knowledge-ids').split(',') : remoteConfig.knowledgeIds,
          swimlanes: urlSwimlanes || remoteConfig.swimlanes,
          journeyId: journeyId
      };

      // Clean up undefined/null values
      Object.keys(state.sessionConfig).forEach(key => 
          state.sessionConfig[key] === null && delete state.sessionConfig[key]
      );

      // Trigger AI Welcome if params exist (but only if we don't have a journeyId already loaded)
      // If we loaded a journeyId, the user likely wants to see the map first, 
      // OR continue the chat. 
      
      // Load History First
      loadHistory();

      // Decision: Only start conversation if history is empty AND no journey ID is present
      // If history exists, we resume. If journey ID exists, we resume context.
      
      // If we have URL params but NO journey ID, we must start a NEW conversation to apply those params.
      // The issue was that sometimes it would load history, see it's empty, but then not start.
      // OR it would see a journeyId in local storage (even if we wanted to reset).
      
      if (!journeyId && state.conversationHistory.length === 0) {
          // Add a small delay to ensure everything is initialized
          setTimeout(() => startConversation(), 500);
      }
    }
    
    function startConversation() {
        // Send a hidden "system start" signal
        // We don't add this to the UI history as a user message
        sendMessage(true); 
    }
    
    // Check for params after a brief delay to ensure DOM is ready
    setTimeout(checkUrlParams, 100);

    // ===========================================
    // Settings Handling
    // ===========================================
    async function fetchSettings() {
        try {
            const response = await fetch('/api/admin/settings');
            if (response.ok) {
                const settings = await response.json();
                if (settings.agentName) {
                    updateAgentName(settings.agentName);
                }
            }
        } catch (e) {
            console.error("Failed to fetch settings", e);
        }
    }

    function updateAgentName(name) {
        // Update Title
        document.title = name;
        
        // Update Meta Description
        document.querySelector('meta[name="description"]').setAttribute('content', `${name} - AI Assistant`);
        
        // Update Placeholder
        const chatInput = document.getElementById('chatInput');
        chatInput.placeholder = `Message ${name}...`;
    }

    // Fetch settings on load
    fetchSettings();

    // ===========================================
    // Input Handling
    // ===========================================
    function autoResize(el) {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 150) + 'px';
    }

    function toggleSendButton() {
      sendButton.disabled = !chatInput.value.trim() || state.isStreaming;
    }

    function handleKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    function useSuggestion(text) {
      chatInput.value = text;
      autoResize(chatInput);
      toggleSendButton();
      chatInput.focus();
    }

    function setInputEnabled(enabled) {
      if (enabled) {
        inputWrapper.classList.remove('disabled');
        chatInput.disabled = false;
      } else {
        inputWrapper.classList.add('disabled');
        chatInput.disabled = true;
      }
      toggleSendButton();
    }

    // ===========================================
    // Typing Indicator
    // ===========================================
    function getDisplayName(type) {
        if (type === 'ai') {
            return (state.sessionConfig.agentName || 'MAX').toUpperCase();
        } else {
            // User
            let name = state.sessionConfig.name;
            if (!name && currentJourney && currentJourney.userName) {
                name = currentJourney.userName;
            }
            if (name) {
                return name.split(' ')[0].toUpperCase();
            }
            return 'YOU';
        }
    }

    function showTypingIndicator() {
      if (document.getElementById('typingIndicator')) return;

      const typingDiv = document.createElement('div');
      typingDiv.className = 'max-typing';
      typingDiv.id = 'typingIndicator';
      
      const name = getDisplayName('ai');

      typingDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-typing-dots">
          <div class="max-typing-dot"></div>
          <div class="max-typing-dot"></div>
          <div class="max-typing-dot"></div>
        </div>
      `;

      messagesArea.appendChild(typingDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    function removeTypingIndicator() {
      const indicator = document.getElementById('typingIndicator');
      if (indicator) {
        indicator.remove();
      }
    }

    // ===========================================
    // Message Handling
    // ===========================================
    async function sendMessage(isSystemStart = false) {
      let text = '';
      
      if (isSystemStart) {
          // Special signal text that won't be shown to user but triggers the backend
          text = "START_SESSION"; 
      } else {
          text = chatInput.value.trim();
          if (!text || state.isStreaming) return;
      }

      // Add user message ONLY if it's not a system start
      if (!isSystemStart) {
          addMessage(text, 'user');
          state.conversationHistory.push({ role: 'user', content: text });
          saveHistory(); // Save
          
          // Clear input
          chatInput.value = '';
          chatInput.style.height = 'auto';
          toggleSendButton();
      }

      // Disable input while streaming
      state.isStreaming = true;
      setInputEnabled(false);

      // Show typing indicator immediately
      showTypingIndicator();

      // We will create the AI message bubble only when text actually arrives
      let aiMessageEl = null;
      let bubbleEl = null;

      try {
        // Start streaming request
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            history: state.conversationHistory.filter(h => h.content !== "START_SESSION"), // Don't send START_SESSION in history if it lingered
            config: state.sessionConfig, // Pass the context/config
            journeyId: currentJourneyId // Pass the ID so the model doesn't lose track
          })
        });

        if (!response.ok) {
          throw new Error('Failed to connect to server');
        }

        // Read SSE stream
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                
                if (data.error) {
                  throw new Error(data.error);
                }
                
                // If we get text and haven't created the bubble yet, do it now
                if (data.text) {
                  if (!aiMessageEl) {
                      removeTypingIndicator();
                      aiMessageEl = createStreamingMessage();
                      bubbleEl = aiMessageEl.querySelector('.max-message-bubble');
                  }
                  
                  fullResponse += data.text;
                  bubbleEl.innerHTML = formatMessage(fullResponse) + '<span class="streaming-cursor"></span>';
                  messagesArea.scrollTop = messagesArea.scrollHeight;
                }
                
                if (data.done) {
                  // If we finished but never got text (e.g. pure tool call?), ensure typing is gone
                  if (!aiMessageEl) removeTypingIndicator();
                  
                  if (aiMessageEl) {
                      // Remove cursor, finalize message
                      bubbleEl.innerHTML = formatMessage(fullResponse);
                      addMessageActions(aiMessageEl);
                      state.conversationHistory.push({ role: 'assistant', content: fullResponse });
                      saveHistory(); // Save
                  }
                  
                  if (data.journeyId) {
                      currentJourneyId = data.journeyId;
                      localStorage.setItem('max_journey_id', currentJourneyId);
                      // Trigger immediate poll
                      pollJourneyState();
                  }
                }
              } catch (e) {
                // Skip malformed JSON
                if (e.message !== 'Unexpected end of JSON input') {
                  throw e;
                }
              }
            }
          }
        }

      } catch (error) {
        console.error('Streaming error:', error);
        removeTypingIndicator();
        
        // Show error message
        if (!aiMessageEl) {
            aiMessageEl = createStreamingMessage();
            bubbleEl = aiMessageEl.querySelector('.max-message-bubble');
        }
        
        bubbleEl.innerHTML = `<p>Sorry, I encountered an error: ${escapeHtml(error.message)}</p>
                             <p>Please make sure the server is running and try again.</p>`;
        aiMessageEl.classList.add('max-message--error');
      }

      // Re-enable input
      state.isStreaming = false;
      setInputEnabled(true);
      chatInput.focus();
    }

    // Create message element for streaming
    function createStreamingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'max-message max-message--ai';
      
      const name = getDisplayName('ai');

      messageDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-message-content">
          <div class="max-message-bubble">
            <span class="streaming-cursor"></span>
          </div>
        </div>
      `;

      messagesArea.appendChild(messageDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
      
      return messageDiv;
    }

    // Add actions to message after streaming completes
    function addMessageActions(messageEl) {
      const contentEl = messageEl.querySelector('.max-message-content');
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'max-message-actions';
      actionsDiv.innerHTML = `
        <button class="max-message-action" onclick="copyMessage(this)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy
        </button>
      `;
      contentEl.appendChild(actionsDiv);
    }

    // Add static message (user messages)
    function addMessage(content, type) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `max-message max-message--${type}`;
      
      const name = getDisplayName(type);

      messageDiv.innerHTML = `
        <div class="max-message-header">${name}</div>
        <div class="max-message-content">
          <div class="max-message-bubble">${type === 'ai' ? formatMessage(content) : escapeHtml(content)}</div>
        </div>
      `;

      messagesArea.appendChild(messageDiv);
      messagesArea.scrollTop = messagesArea.scrollHeight;
    }

    // ===========================================
    // Formatting Helpers
    // ===========================================
    function _legacy_escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function _legacy_formatMessage(text) {
      // Basic markdown-like formatting
      let formatted = escapeHtml(text);
      
      // Code blocks
      formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
      
      // Inline code
      formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
      
      // Headers (###)
      formatted = formatted.replace(/^###\s+(.*$)/gm, '<h3>$1</h3>');
      
      // Bold
      formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      
      // Italic
      formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      
      // Line breaks to paragraphs
      formatted = formatted
        .split(/\n\n+/)
        .map(para => para.trim())
        .filter(para => para)
        .map(para => {
          // Check if it's a list
          if (para.match(/^[-*â¢]\s/m)) {
            const items = para.split(/\n/).map(item => 
              `<li>${item.replace(/^[-*â¢]\s*/, '')}</li>`
            ).join('');
            return `<ul>${items}</ul>`;
          }
          // Check if it's a numbered list
          if (para.match(/^\d+\.\s/m)) {
            const items = para.split(/\n/).map(item => 
              `<li>${item.replace(/^\d+\.\s*/, '')}</li>`
            ).join('');
            return `<ol>${items}</ol>`;
          }
          return `<p>${para.replace(/\n/g, '<br>')}</p>`;
        })
        .join('');
      
      return formatted;
    }

    // Copy message content
    function copyMessage(btn) {
      const bubble = btn.closest('.max-message-content').querySelector('.max-message-bubble');
      navigator.clipboard.writeText(bubble.innerText);
      btn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"/>
        </svg>
        Copied!
      `;
      setTimeout(() => {
        btn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy
        `;
      }, 2000);
    }

    // Copy Full Conversation
    function copyConversation() {
        if (!state.conversationHistory || state.conversationHistory.length === 0) {
            alert("No conversation history to copy. (History is cleared on page reload)");
            return;
        }

        const text = state.conversationHistory
            .map(msg => `[${msg.role.toUpperCase()}]\n${msg.content}`)
            .join('\n\n-------------------\n\n');
        
        navigator.clipboard.writeText(text).then(() => {
            const btn = document.getElementById('copyConvBtn');
            const originalHtml = btn.innerHTML;
            
            btn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: #22c55e;">
                  <polyline points="20 6 9 17 4 12"/>
                </svg>
                Copied!
            `;
            
            setTimeout(() => {
                btn.innerHTML = originalHtml;
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy: ', err);
            alert('Failed to copy conversation to clipboard.');
        });
    }

    // Export to PDF
    function _legacy_exportToPdf(targetElementId = 'journeyDashboard') {
        const element = document.getElementById('journeyDashboard');
        const opt = {
          margin:       0.2, // Small margin
          filename:     `journey-map-${new Date().toISOString().split('T')[0]}.pdf`,
          image:        { type: 'jpeg', quality: 0.98 },
          html2canvas:  { scale: 2, useCORS: true },
          jsPDF:        { unit: 'in', format: 'letter', orientation: 'landscape' }
        };

        html2pdf().set(opt).from(element).save();
    }

    // Export to FigJam (Placeholder)
    function _legacy_exportToFigJam() {
        alert("Export to FigJam is coming soon!");
    }

    // Reset / New Journey
    function startNewJourney() {
        // 1. Clear Local Storage History
        clearHistory(); 
        
        // 2. If we have a current journey ID, we should probably delete it from the backend 
        //    so it doesn't clutter the admin (optional, but requested "erase session")
        if (currentJourneyId) {
            // Fire and forget delete - we don't need to wait for it
            fetch(`/v1/journey-maps/${currentJourneyId}`, { method: 'DELETE' });
        }

        // 3. Clear Persistent ID
        localStorage.removeItem('max_journey_id'); 
        
        // 4. When resetting with URL params, we want to START FRESH, not resume.
        //    The issue is checkUrlParams might see a journeyId if we don't clear the URL.
        const url = new URL(window.location.href);
        url.searchParams.delete('journeyId');
        
        // 5. Hard Reload to ensure fresh state
        window.location.href = url.toString();
    }

    function hardReset() {
        if(confirm("Start over completely? This clears the current chat.")) {
            startNewJourney();
        }
    }

    function toggleMobileView() {
        document.body.classList.toggle('show-map');
        const btn = document.getElementById('mobileToggleBtn');
        if (document.body.classList.contains('show-map')) {
            btn.textContent = 'Chat';
        } else {
            btn.textContent = 'Map';
        }
    }

    // Fullscreen Toggle
    function toggleFullscreen() {
        const doc = window.document;
        const docEl = doc.documentElement;

        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            if (requestFullScreen) {
                requestFullScreen.call(docEl);
            } else {
                // Fallback for Safari iOS if API not supported on element
                alert("To use fullscreen on iOS, tap the 'Share' button and select 'Add to Home Screen'.");
            }
        } else {
            if (cancelFullScreen) {
                cancelFullScreen.call(doc);
            }
        }
    }
  </script>
</body>
</html>
